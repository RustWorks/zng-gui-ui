//! Aggregate events.

use crate::core::app::*;
use crate::core::context::*;
use crate::core::event::*;
use crate::core::keyboard::*;
use crate::core::mouse::*;
use crate::core::render::*;
use crate::core::types::*;
use std::convert::{TryFrom, TryInto};
use std::fmt::{self, Display};
use std::num::NonZeroU8;

/// Specific information from the source of a [`ClickArgs`].
#[derive(Debug, Clone)]
pub enum ClickArgsSource {
    /// Click event was generated by the [mouse click event](MouseClickEvent).
    Mouse {
        /// Which mouse button generated the event.
        button: MouseButton,

        /// Position of the mouse in the coordinates of [`target`](ClickArgs::target).
        position: LayoutPoint,

        /// Hit-test result for the mouse point in the window, at the moment the click event
        /// was generated.
        hits: FrameHitInfo,
    },

    /// Click event was generated by the [key down event](KeyDownEvent) with the
    /// [`VirtualKeyCode::Return`](VirtualKeyCode::Return) key.
    Key {
        /// If the key-down event was generated by holding the key pressed.
        repeat: bool,
    },
}

event_args! {
    /// [`Click`] event args.
    pub struct ClickArgs {
        /// Id of window that received the event.
        pub window_id: WindowId,

        /// Id of device that generated the event.
        ///
        /// Is `None` if the event was generated programmatically.
        pub device_id: Option<DeviceId>,

        /// Specific info from the source of this event.
        pub source: ClickArgsSource,

        /// Sequential click count . Number `1` is single click, `2` is double click, etc.
        ///
        /// This is always `1` for clicks initiated by the keyboard.
        pub click_count: NonZeroU8,

        // What modifier keys where pressed when this event happened.
        pub modifiers: ModifiersState,

        /// The mouse input top-most hit or the focused element at the time of the key input.
        pub target: WidgetPath,

        ..

        /// If the widget is in [`target`](ClickArgs::target).
        fn concerns_widget(&self, ctx: &mut WidgetContext) -> bool {
            self.target.contains(ctx.widget_id)
        }
    }
}

impl From<MouseClickArgs> for ClickArgs {
    #[inline]
    fn from(args: MouseClickArgs) -> Self {
        ClickArgs::new(
            args.timestamp,
            args.window_id,
            args.device_id,
            ClickArgsSource::Mouse {
                button: args.button,
                position: args.position,
                hits: args.hits,
            },
            args.click_count,
            args.modifiers,
            args.target,
        )
    }
}

impl TryFrom<KeyInputArgs> for ClickArgs {
    type Error = KeyInputArgs;

    /// Converts to click args if `[key_input_is_click](key_input_is_click)(&args)`, otherwise returns
    /// the key input args.
    #[inline]
    fn try_from(args: KeyInputArgs) -> Result<Self, Self::Error> {
        if key_input_is_click(&args) {
            Ok(ClickArgs::new(
                args.timestamp,
                args.window_id,
                args.device_id,
                ClickArgsSource::Key { repeat: args.repeat },
                NonZeroU8::new(1).unwrap(),
                args.modifiers,
                args.target,
            ))
        } else {
            Err(args)
        }
    }
}

/// If is a [`Return`](VirtualKeyCode::Return) key press and [`target`](KeyInputArgs::target) is some widget.
#[inline]
pub fn key_input_is_click(args: &KeyInputArgs) -> bool {
    args.key == Some(VirtualKeyCode::Return) && args.state == ElementState::Pressed
}

impl ClickArgs {
    //// If the event was generated by holding the return key key pressed.
    #[inline]
    pub fn is_repeat(&self) -> bool {
        match &self.source {
            ClickArgsSource::Key { repeat, .. } => *repeat,
            _ => false,
        }
    }

    /// If the event counts as a left click.
    #[inline]
    pub fn is_left(&self) -> bool {
        match &self.source {
            ClickArgsSource::Mouse { button, .. } => *button == MouseButton::Left,
            _ => true,
        }
    }

    /// If this event was generated by a mouse device.
    #[inline]
    pub fn is_from_mouse(&self) -> bool {
        match &self.source {
            ClickArgsSource::Mouse { .. } => true,
            _ => false,
        }
    }

    /// If this event was generated by a keyboard device.
    #[inline]
    pub fn is_from_keyboard(&self) -> bool {
        match &self.source {
            ClickArgsSource::Key { .. } => true,
            _ => false,
        }
    }
}

/// A keyboard combination.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct KeyGesture {
    pub key: GestureKey,
    pub modifiers: ModifiersState,
}
impl Display for KeyGesture {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.modifiers.logo() {
            write!(f, "logo + ")?
        }
        if self.modifiers.ctrl() {
            write!(f, "ctrl + ")?
        }
        if self.modifiers.shift() {
            write!(f, "shift + ")?
        }
        if self.modifiers.alt() {
            write!(f, "alt + ")?
        }

        write!(f, "{}", self.key)
    }
}

/// A sequence of two keyboard combinations.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct KeyChord {
    /// The first key gesture.
    pub starter: KeyGesture,

    /// The second key gesture.
    pub complement: KeyGesture,
}
impl Display for KeyChord {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} {}", self.starter, self.complement)
    }
}

/// Keyboard gesture or chord associated with a command.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum KeyBinding {
    Gesture(KeyGesture),
    Chord(KeyChord),
}
impl Display for KeyBinding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            KeyBinding::Gesture(g) => write!(f, "{}", g),
            KeyBinding::Chord(c) => write!(f, "{}", c),
        }
    }
}

impl KeyInputArgs {
    /// Key gesture this key press triggers.
    #[inline]
    pub fn gesture(&self) -> Option<KeyGesture> {
        if self.state == ElementState::Released {
            return None;
        }

        self.key.and_then(|k| k.try_into().ok()).map(|key| KeyGesture {
            key,
            modifiers: self.modifiers,
        })
    }
}

impl From<KeyGesture> for KeyBinding {
    #[inline]
    fn from(g: KeyGesture) -> Self {
        KeyBinding::Gesture(g)
    }
}

impl From<KeyChord> for KeyBinding {
    #[inline]
    fn from(c: KeyChord) -> Self {
        KeyBinding::Chord(c)
    }
}

event! {
    /// Aggregate click event. Can be a mouse click, a [return key](VirtualKeyCode::Return) press or a touch tap.
    pub ClickEvent: ClickArgs;

    /// [`ClickEvent`] when the [`click_count`](ClickArgs::click_count) is `1`.
    pub SingleClickEvent: ClickArgs;

    /// [`ClickEvent`] when the [`click_count`](ClickArgs::click_count) is `2`.
    pub DoubleClickEvent: ClickArgs;

    /// [`ClickEvent`] when the [`click_count`](ClickArgs::click_count) is `3`.
    pub TripleClickEvent: ClickArgs;
}

/// Application extension that provides aggregate events.
///
/// Events this extension provides.
///
/// * [ClickEvent]
/// * [SingleClickEvent]
/// * [DoubleClickEvent]
/// * [TripleClickEvent]
pub struct GestureManager {
    key_down: EventListener<KeyInputArgs>,
    mouse_click: EventListener<MouseClickArgs>,

    click: EventEmitter<ClickArgs>,
    single_click: EventEmitter<ClickArgs>,
    double_click: EventEmitter<ClickArgs>,
    triple_click: EventEmitter<ClickArgs>,
}

impl Default for GestureManager {
    fn default() -> Self {
        GestureManager {
            key_down: KeyDownEvent::never(),
            mouse_click: MouseClickEvent::never(),

            click: ClickEvent::emitter(),
            single_click: SingleClickEvent::emitter(),
            double_click: DoubleClickEvent::emitter(),
            triple_click: TripleClickEvent::emitter(),
        }
    }
}

impl AppExtension for GestureManager {
    fn init(&mut self, r: &mut AppInitContext) {
        self.key_down = r.events.listen::<KeyDownEvent>();
        self.mouse_click = r.events.listen::<MouseClickEvent>();
        r.events.register::<ClickEvent>(self.click.listener());
    }

    fn update(&mut self, update: UpdateRequest, ctx: &mut AppContext) {
        if update.update {
            let notify_single = self.single_click.has_listeners();
            let notify_double = self.double_click.has_listeners();
            let notify_triple = self.triple_click.has_listeners();

            for args in self.mouse_click.updates(ctx.events) {
                let args: ClickArgs = args.clone().into();

                match args.click_count.get() {
                    1 if notify_single => ctx.updates.push_notify(self.single_click.clone(), args.clone()),
                    2 if notify_double => ctx.updates.push_notify(self.double_click.clone(), args.clone()),
                    3 if notify_triple => ctx.updates.push_notify(self.triple_click.clone(), args.clone()),
                    _ => {}
                }

                ctx.updates.push_notify(self.click.clone(), args);
            }

            for args in self.key_down.updates(ctx.events) {
                if key_input_is_click(args) {
                    let args: ClickArgs = args.clone().try_into().unwrap();

                    if notify_single {
                        ctx.updates.push_notify(self.single_click.clone(), args.clone());
                    }

                    ctx.updates.push_notify(self.click.clone(), args);
                }
            }
        }
    }
}

macro_rules! gesture_key_name {
    ($key:ident = $name:expr) => {
        $name
    };
    ($key:ident) => {
        stringify!($key)
    };
}

macro_rules! gesture_keys {
    ($($key:ident $(= $name:expr)?),+) => {
        /// The set of keys that can be used in a [`KeyGesture`].
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        pub enum GestureKey {
            $($key),+
        }
        impl TryFrom<VirtualKeyCode> for GestureKey {
            type Error = VirtualKeyCode;

            fn try_from(key: VirtualKeyCode) -> Result<Self, VirtualKeyCode> {
                match key {
                    $(VirtualKeyCode::$key => Ok(GestureKey::$key),)+
                    _ => Err(key)
                }
            }
        }
        impl Display for GestureKey {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    $(GestureKey::$key => write!(f, gesture_key_name!($key $(=$name)?)),)+
                }
            }
        }
    };
}

gesture_keys! {
    Key1 = "1",
    Key2 = "2",
    Key3 = "3",
    Key4 = "4",
    Key5 = "5",
    Key6 = "6",
    Key7 = "7",
    Key8 = "8",
    Key9 = "9",
    Key0 = "0",
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Escape = "Esc",
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    Pause,
    Insert,
    Home,
    Delete,
    End,
    PageDown = "Page Down",
    PageUp = "Page Up",
    Left,
    Up,
    Right,
    Down,
    Back,
    Return,
    Space,
    Add = "+",
    Apostrophe = "'",
    Backslash = "\\",
    Comma = ",",
    Decimal = ".",
    Divide = "/",
    Equals = "=",
    Minus = "-",
    Multiply = "*",
    Numpad1 = "Numpad 1",
    Numpad2 = "Numpad 2",
    Numpad3 = "Numpad 3",
    Numpad4 = "Numpad 4",
    Numpad5 = "Numpad 5",
    Numpad6 = "Numpad 6",
    Numpad7 = "Numpad 7",
    Numpad8 = "Numpad 8",
    Numpad9 = "Numpad 9",
    Numpad0 = "Numpad 0",
    NumpadComma = "Numpad ,"
}
