//! Aggregate events.

use crate::core::app::*;
use crate::core::context::*;
use crate::core::event::*;
use crate::core::keyboard::*;
use crate::core::mouse::*;
use crate::core::render::*;
use crate::core::types::*;
use std::convert::{TryFrom, TryInto};
use std::num::NonZeroU8;

/// Specific information from the source of a [ClickArgs].
#[derive(Debug, Clone)]
pub enum ClickArgsSource {
    /// Click event was generated by the [MouseClick] event.
    Mouse {
        button: MouseButton,
        position: LayoutPoint,
        hits: FrameHitInfo,
    },

    /// Click event was generated by the [KeyDown] event with the [VirtualKeyCode::Return] key.
    Key {
        /// If the key-down event was generated by holding the key pressed.
        repeat: bool,

        /// The focused element at the time of the key input.
        target: WidgetPath,
    },
}

event_args! {
    /// [Click] event args.
    pub struct ClickArgs {
        /// Id of window that received the event.
        pub window_id: WindowId,

         /// Id of device that generated the event.
        pub device_id: DeviceId,

        /// Specific info from the source of this event.
        pub source: ClickArgsSource,

        /// Sequential click count . Number `1` is single click, `2` is double click, etc.
        ///
        /// This is always `1` for clicks initiated by the keyboard.
        pub click_count: NonZeroU8,

        // What modifier keys where pressed when this event happened.
        pub modifiers: ModifiersState,

        ..

        /// If the widget is in [hits](ClickArgsSource::Mouse::hits) or [target](ClickArgsSource::Key::target).
        fn concerns_widget(&self, ctx: &mut WidgetContext) -> bool {
            match &self.source {
                ClickArgsSource::Mouse { hits, .. } => hits.contains(ctx.widget_id),
                ClickArgsSource::Key { target, .. } => target.contains(ctx.widget_id),
            }
        }
    }
}

impl From<MouseClickArgs> for ClickArgs {
    #[inline]
    fn from(args: MouseClickArgs) -> Self {
        ClickArgs::new(
            args.timestamp,
            args.window_id,
            args.device_id,
            ClickArgsSource::Mouse {
                button: args.button,
                position: args.position,
                hits: args.hits,
            },
            args.click_count,
            args.modifiers,
        )
    }
}

impl TryFrom<KeyInputArgs> for ClickArgs {
    type Error = KeyInputArgs;

    /// Converts to click args if `[key_input_is_click](&args)`, otherwise returns
    /// the key input args.
    #[inline]
    fn try_from(args: KeyInputArgs) -> Result<Self, Self::Error> {
        if key_input_is_click(&args) {
            Ok(ClickArgs::new(
                args.timestamp,
                args.window_id,
                args.device_id,
                ClickArgsSource::Key {
                    repeat: args.repeat,
                    target: args.target.unwrap(),
                },
                NonZeroU8::new(1).unwrap(),
                args.modifiers,
            ))
        } else {
            Err(args)
        }
    }
}

/// If is a [return](VirtualKeyCode::Return) key press and [target](KeyInputArgs::target) is some widget.
#[inline]
pub fn key_input_is_click(args: &KeyInputArgs) -> bool {
    args.key == Some(VirtualKeyCode::Return) && args.state == ElementState::Pressed
}

impl ClickArgs {
    //// If the event was generated by holding the return key key pressed.
    #[inline]
    pub fn repeat(&self) -> bool {
        match &self.source {
            ClickArgsSource::Key { repeat, .. } => *repeat,
            _ => false,
        }
    }

    /// If this event was generated by a mouse device.
    #[inline]
    pub fn is_from_mouse(&self) -> bool {
        match &self.source {
            ClickArgsSource::Mouse { .. } => true,
            _ => false,
        }
    }

    /// If this event was generated by a keyboard device.
    #[inline]
    pub fn is_from_keyboard(&self) -> bool {
        match &self.source {
            ClickArgsSource::Key { .. } => true,
            _ => false,
        }
    }
}

/// Aggregate click event. Can be a mouse click, a [return key](VirtualKeyCode::Return) press or a touch tap.
pub struct Click;
impl Event for Click {
    type Args = ClickArgs;
}

/// [Click] when the [click_count](ClickArgs::click_count) is `1`.
pub struct SingleClick;
impl Event for SingleClick {
    type Args = ClickArgs;
}

/// Application extension that provides aggregate events.
pub struct GestureEvents {
    key_down: EventListener<KeyInputArgs>,
    mouse_click: EventListener<MouseClickArgs>,

    click: EventEmitter<ClickArgs>,
    single_click: EventEmitter<ClickArgs>,
}

impl Default for GestureEvents {
    fn default() -> Self {
        GestureEvents {
            key_down: EventListener::never(false),
            mouse_click: EventListener::never(false),

            click: EventEmitter::new(false),
            single_click: EventEmitter::new(false),
        }
    }
}

impl AppExtension for GestureEvents {
    fn init(&mut self, r: &mut AppInitContext) {
        self.key_down = r.events.listen::<KeyDown>();
        self.mouse_click = r.events.listen::<MouseClick>();
        r.events.register::<Click>(self.click.listener());
    }

    fn update(&mut self, update: UpdateRequest, ctx: &mut AppContext) {
        if update.update {
            let notify_single = self.single_click.has_listeners();

            for args in self.mouse_click.updates(ctx.events) {
                let args: ClickArgs = args.clone().into();

                if notify_single && args.click_count.get() == 1 {
                    ctx.updates.push_notify(self.single_click.clone(), args.clone());
                }

                ctx.updates.push_notify(self.click.clone(), args);
            }

            for args in self.key_down.updates(ctx.events) {
                if key_input_is_click(args) {
                    let args: ClickArgs = args.clone().try_into().unwrap();

                    if notify_single {
                        ctx.updates.push_notify(self.single_click.clone(), args.clone());
                    }

                    ctx.updates.push_notify(self.click.clone(), args);
                }
            }
        }
    }
}
