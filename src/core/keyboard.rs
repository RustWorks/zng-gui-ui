//! Keyboard manager.
//!
//! The [`KeyboardManager`] struct is an [app extension](crate::core::app::AppExtension). It
//! is included in the [default app](crate::core::app::App::default) and provides the [`Keyboard`] service
//! and keyboard input events.

use crate::core::app::*;
use crate::core::context::*;
use crate::core::event::*;
use crate::core::focus::Focus;
use crate::core::render::WidgetPath;
use crate::core::service::*;
use crate::core::types::*;
use crate::core::window::{WindowId, Windows};

event_args! {
    /// Keyboard event args.
    pub struct KeyInputArgs {
        /// Id of window that received the event.
        pub window_id: WindowId,

        /// Id of device that generated the event.
        ///
        /// Is `None` if the event was generated programmatically.
        pub device_id: Option<DeviceId>,

        /// Raw code of key.
        pub scan_code: ScanCode,

        /// If the key was pressed or released.
        pub state: ElementState,

        /// Symbolic name of [`scancode`](KeyInputArgs::scancode).
        pub key: Option<VirtualKeyCode>,

        /// What modifier keys where pressed when this event happened.
        pub modifiers: ModifiersState,

        /// If the key-down event was generated by holding the key pressed.
        pub repeat: bool,

        /// The focused element at the time of the key input.
        pub target: WidgetPath,

        ..

        /// If the widget is focused or contains the focused widget.
        fn concerns_widget(&self, ctx: &mut WidgetContext) -> bool {
            self.target.contains(ctx.path.widget_id())
        }
    }

    /// Character received event args.
    pub struct CharInputArgs {
        /// Id of window that received the event.
        pub window_id: WindowId,

        /// The character.
        pub character: char,

        /// The focused element at the time of the key input.
        pub target: WidgetPath,

        ..

        /// If the widget is focused or contains the focused widget.
        fn concerns_widget(&self, ctx: &mut WidgetContext) -> bool {
            self.target.contains(ctx.path.widget_id())
        }
    }

    /// Keyboard modifiers changed event args.
    pub struct ModifiersChangedArgs {
        /// Previous modifiers state.
        pub prev_modifiers: ModifiersState,

        /// Current modifiers state.
        pub modifiers: ModifiersState,

        /// The focused element at the time of the update.
        pub target: WidgetPath,

        ..

        /// If the widget is focused or contains the focused widget.
        fn concerns_widget(&self, ctx: &mut WidgetContext) -> bool {
            self.target.contains(ctx.path.widget_id())
        }
    }
}

event! {
    /// Key pressed or released event.
    pub KeyInputEvent: KeyInputArgs;

    /// Key pressed or repeat event.
    pub KeyDownEvent: KeyInputArgs;

    /// Key released event.
    pub KeyUpEvent: KeyInputArgs;

    /// Modifiers state changed event.
    pub ModifiersChangedEvent: ModifiersChangedArgs;

    /// Character received event.
    pub CharInputEvent: CharInputArgs;
}

/// Application extension that provides keyboard events.
///
/// # Events
///
/// Events this extension provides.
///
/// * [KeyInputEvent]
/// * [KeyDownEvent]
/// * [KeyUpEvent]
/// * [ModifiersChangedEvent]
/// * [CharInputEvent]
///
/// # Services
///
/// Services this extension provides.
///
/// * [Keyboard]
#[derive(Default)]
pub struct KeyboardManager;
impl KeyboardManager {
    fn target(window_id: WindowId, services: &mut AppServices) -> WidgetPath {
        let focused = services.get::<Focus>().and_then(|f| f.focused().cloned());
        if let Some(focused) = focused {
            focused
        } else {
            services.req::<Windows>().window(window_id).unwrap().frame_info().root().path()
        }
    }
}
impl AppExtension for KeyboardManager {
    fn init(&mut self, r: &mut AppInitContext) {
        let k = Keyboard::new(r.events);
        r.services.register(k);
    }

    fn on_window_event(&mut self, window_id: WindowId, event: &WindowEvent, ctx: &mut AppContext) {
        match *event {
            WindowEvent::KeyboardInput {
                device_id,
                input:
                    KeyboardInput {
                        scancode,
                        state,
                        virtual_keycode: key,
                        ..
                    },
                ..
            } => {
                let target = Self::target(window_id, ctx.services);
                ctx.services
                    .req::<Keyboard>()
                    .device_input(device_id, scancode, key, state, target, ctx.events);
            }

            WindowEvent::ModifiersChanged(m) => {
                let target = Self::target(window_id, ctx.services);
                ctx.services.req::<Keyboard>().set_modifiers(m, target, ctx.events);
            }

            WindowEvent::ReceivedCharacter(c) => {
                let target = Self::target(window_id, ctx.services);
                ctx.services.req::<Keyboard>().char_input(c, target, ctx.events);
            }

            _ => {}
        }
    }
}

/// Keyboard service.
///
/// # Provider
///
/// This service is provided by the [`KeyboardManager`] extension.
pub struct Keyboard {
    modifiers: ModifiersState,
    last_key_down: Option<(Option<DeviceId>, ScanCode)>,

    key_input: EventEmitter<KeyInputArgs>,
    key_down: EventEmitter<KeyInputArgs>,
    key_up: EventEmitter<KeyInputArgs>,

    modifiers_changed: EventEmitter<ModifiersChangedArgs>,

    char_input: EventEmitter<CharInputArgs>,
}
impl AppService for Keyboard {}
impl Keyboard {
    pub fn new(events: &mut Events) -> Self {
        let self_ = Keyboard {
            modifiers: ModifiersState::empty(),
            last_key_down: None,

            key_input: KeyInputEvent::emitter(),
            key_down: KeyDownEvent::emitter(),
            key_up: KeyUpEvent::emitter(),

            modifiers_changed: ModifiersChangedEvent::emitter(),

            char_input: CharInputEvent::emitter(),
        };

        events.register::<KeyInputEvent>(self_.key_input.listener());
        events.register::<KeyDownEvent>(self_.key_down.listener());
        events.register::<KeyUpEvent>(self_.key_up.listener());
        events.register::<ModifiersChangedEvent>(self_.modifiers_changed.listener());
        events.register::<CharInputEvent>(self_.char_input.listener());

        self_
    }

    /// Process a software keyboard input.
    #[inline]
    pub fn input(&mut self, key: VirtualKeyCode, state: ElementState, target: WidgetPath, events: &Events) {
        self.do_input(None, key as ScanCode, Some(key), state, target, events);
    }

    /// Process a external keyboard input.
    #[inline]
    pub fn device_input(
        &mut self,
        device_id: DeviceId,
        scan_code: ScanCode,
        key: Option<VirtualKeyCode>,
        state: ElementState,
        target: WidgetPath,
        events: &Events,
    ) {
        self.do_input(Some(device_id), scan_code, key, state, target, events);
    }

    /// Set the keyboard modifiers state.
    pub fn set_modifiers(&mut self, modifiers: ModifiersState, target: WidgetPath, events: &Events) {
        if self.modifiers != modifiers {
            let prev_modifiers = std::mem::replace(&mut self.modifiers, modifiers);
            let args = ModifiersChangedArgs::now(prev_modifiers, modifiers, target);
            self.modifiers_changed.notify(events, args);
        }
    }

    /// Character input.
    pub fn char_input(&mut self, character: char, target: WidgetPath, events: &Events) {
        let args = CharInputArgs::now(target.window_id(), character, target);
        self.char_input.notify(events, args);
    }

    /// Current modifiers pressed.
    #[inline]
    pub fn modifiers(&self) -> ModifiersState {
        self.modifiers
    }

    fn do_input(
        &mut self,
        device_id: Option<DeviceId>,
        scan_code: ScanCode,
        key: Option<VirtualKeyCode>,
        state: ElementState,
        target: WidgetPath,
        events: &Events,
    ) {
        let mut repeat = false;
        if state == ElementState::Pressed {
            repeat = self.last_key_down == Some((device_id, scan_code));
            if !repeat {
                self.last_key_down = Some((device_id, scan_code));
            }
        } else {
            self.last_key_down = None;
        }

        let args = KeyInputArgs::now(target.window_id(), device_id, scan_code, state, key, self.modifiers, repeat, target);

        self.key_input.notify(events, args.clone());

        let specific_event = match args.state {
            ElementState::Pressed => &self.key_down,
            ElementState::Released => &self.key_up,
        };
        specific_event.notify(events, args);
    }
}
