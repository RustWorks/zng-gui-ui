use super::{AppContext, AppContextId, AppContextOwnership, WidgetId};
use fnv::FnvHashMap;
use std::any::type_name;
use std::cell::{Cell, RefCell, UnsafeCell};
use std::marker::PhantomData;
use std::mem::MaybeUninit;
use std::rc::Rc;

/// A variable value that is set by the ancestors of an UiNode.
pub trait ContextVar: Clone + Copy + 'static {
    /// The variable type.
    type Type: 'static;

    /// Default value, used when the variable is not set in the context.
    fn default() -> &'static Self::Type;
}

/// A variable value that is set by the previously visited UiNodes during the call.
pub trait VisitedVar: 'static {
    /// The variable type.
    type Type: 'static;
}

pub(crate) mod protected {
    use super::AppContext;
    use std::any::TypeId;

    /// Info for context var binding.
    pub enum BindInfo<'a, T: 'static> {
        /// Owned or SharedVar.
        ///
        /// * `&'a T` is a reference to the value borrowed in the context.
        /// * `bool` is the is_new flag.
        Var(&'a T, bool, u32),
        /// ContextVar.
        ///
        /// * `TypeId` of self.
        /// * `&'static T` is the ContextVar::default value of self.
        /// * `Option<(bool, u32)>` optional is_new and version override.
        ContextVar(TypeId, &'static T, Option<(bool, u32)>),
    }

    /// pub(crate) part of `SizedVar`.
    pub trait Var<T: 'static> {
        fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> BindInfo<'a, T>;

        fn is_context_var(&self) -> bool {
            false
        }

        fn read_only_prev_version(&self) -> u32 {
            0
        }
    }

    /// pub(crate) part of `SwitchVar`.
    pub trait SwitchVar<T: 'static>: Var<T> {
        fn modify(self, new_index: usize, cleanup: &mut Vec<Box<dyn FnOnce()>>);
    }
}

/// Error when trying to set or motify a read-only variable.
#[derive(Debug, Hash, PartialEq, Eq)]
pub struct VarIsReadOnly;

impl std::fmt::Display for VarIsReadOnly {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "cannot set or modify read-only variable")
    }
}

impl std::error::Error for VarIsReadOnly {}

/// Part of [Var] that can be boxed.
pub trait SizedVar<T: 'static>: protected::Var<T> + 'static {
    /// The current value.
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a T;

    /// [get] if [is_new] or none.
    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a T>;

    /// If the value changed this update.
    fn is_new(&self, ctx: &AppContext) -> bool;

    /// Current value version. Version changes every time the value changes.
    fn version(&self, ctx: &AppContext) -> u32;

    /// Gets if the variable is currently read-only.
    fn read_only(&self) -> bool {
        true
    }

    /// Gets if the variable is always read-only.
    fn always_read_only(&self) -> bool {
        true
    }

    /// Schedules a variable change for the next update if the variable is not [read_only].
    fn push_set(&self, _new_value: T, _ctx: &mut AppContext) -> Result<(), VarIsReadOnly> {
        Err(VarIsReadOnly)
    }

    /// Box the variable. This disables mapping.
    fn into_box(self) -> BoxVar<T>
    where
        Self: std::marker::Sized,
    {
        Box::new(self)
    }
}

/// Boxed [SizedVar].
pub type BoxVar<T> = Box<dyn SizedVar<T>>;

/// A value that can change. Can [own the value](OwnedVar) or be a [reference](SharedVar).
///
/// This is the complete generic trait, the non-generic methods are defined in [SizedVar]
/// to support boxing.
///
/// Cannot be implemented outside of zero-ui crate. Use this together with [IntoVar] to
/// support dinamic values in property definitions.
pub trait Var<T: 'static>: SizedVar<T> {
    /// Return type of [as_read_only].
    type AsReadOnly: Var<T>;

    /// Schedules a variable modification for the next update.
    fn push_modify(&self, _modify: impl FnOnce(&mut T) + 'static, _ctx: &mut AppContext) -> Result<(), VarIsReadOnly> {
        Err(VarIsReadOnly)
    }

    /// Produces a variable generated by the value of this variable. If this
    /// variable changes the map variable changes too.
    fn map<O: 'static, M: FnMut(&T) -> O + 'static>(&self, map: M) -> MapVar<T, Self, O, M>
    where
        Self: Sized;

    /// Ensures this variable is [always_read_only].
    fn as_read_only(self) -> Self::AsReadOnly;
}

impl<T: 'static, V: ContextVar<Type = T>> protected::Var<T> for V {
    fn bind_info<'a, 'b>(&'a self, _: &'b AppContext) -> protected::BindInfo<'a, T> {
        protected::BindInfo::ContextVar(std::any::TypeId::of::<V>(), V::default(), None)
    }

    fn is_context_var(&self) -> bool {
        true
    }
}

impl<T: 'static, V: ContextVar<Type = T>> SizedVar<T> for V {
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a T {
        ctx.get::<V>()
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a T> {
        ctx.get_new::<V>()
    }

    fn is_new(&self, ctx: &AppContext) -> bool {
        ctx.get_is_new::<V>()
    }

    fn version(&self, ctx: &AppContext) -> u32 {
        ctx.get_version::<V>()
    }
}

impl<T: 'static, V: ContextVar<Type = T>> Var<T> for V {
    type AsReadOnly = Self;

    fn map<O: 'static, M: FnMut(&T) -> O + 'static>(&self, map: M) -> MapVar<T, Self, O, M> {
        MapVar::new(MapVarInner::Context(MapContextVar::new(*self, map)))
    }

    fn as_read_only(self) -> Self {
        self
    }
}

/// [Var] implementer that owns the value.
pub struct OwnedVar<T: 'static>(pub T);

impl<T: 'static> protected::Var<T> for OwnedVar<T> {
    fn bind_info<'a, 'b>(&'a self, _: &'b AppContext) -> protected::BindInfo<'a, T> {
        protected::BindInfo::Var(&self.0, false, 0)
    }
}

impl<T: 'static> SizedVar<T> for OwnedVar<T> {
    fn get(&self, _: &AppContext) -> &T {
        &self.0
    }

    fn update<'a>(&'a self, _: &'a AppContext) -> Option<&'a T> {
        None
    }

    fn is_new(&self, _: &AppContext) -> bool {
        false
    }

    fn version(&self, _: &AppContext) -> u32 {
        0
    }
}

impl<T: 'static> Var<T> for OwnedVar<T> {
    type AsReadOnly = Self;

    fn map<O: 'static, M: FnMut(&T) -> O + 'static>(&self, mut map: M) -> MapVar<T, Self, O, M> {
        MapVar::new(MapVarInner::Owned(OwnedVar(map(&self.0))))
    }

    fn as_read_only(self) -> Self {
        self
    }
}

struct SharedVarInner<T> {
    data: UnsafeCell<T>,
    context: AppContextOwnership,
    is_new: Cell<bool>,
    version: Cell<u32>,
}

/// [Var] Rc implementer.
pub struct SharedVar<T: 'static> {
    r: Rc<SharedVarInner<T>>,
}

impl<T: 'static> SharedVar<T> {
    pub(crate) fn modify(
        self,
        mut_ctx_id: AppContextId,
        modify: impl FnOnce(&mut T) + 'static,
        cleanup: &mut Vec<Box<dyn FnOnce()>>,
    ) {
        self.r.context.check(
            mut_ctx_id,
            format_args!(
                "cannot set `SharedVar<{}>` because it is bound to a different `AppContext`",
                type_name::<T>()
            ),
        );

        // SAFETY: This is safe because borrows are bound to a context that
        // is the only place where the value can be changed and this change is
        // only applied when the context is mut.
        modify(unsafe { &mut *self.r.data.get() });
        self.r.version.set(self.next_version());

        cleanup.push(Box::new(move || self.r.is_new.set(false)));
    }

    fn borrow(&self, ctx_id: AppContextId) -> &T {
        self.r.context.check(
            ctx_id,
            format_args!(
                "cannot borrow `SharedVar<{}>` because it is bound to a different `AppContext`",
                type_name::<T>()
            ),
        );

        // SAFETY: This is safe because borrows are bound to a context that
        // is the only place where the value can be changed and this change is
        // only applied when the context is mut.
        unsafe { &*self.r.data.get() }
    }

    /// Gets the [version] this variable will be in the next update if set in this update.
    pub fn next_version(&self) -> u32 {
        self.r.version.get().wrapping_add(1)
    }
}

impl<T: 'static> Clone for SharedVar<T> {
    fn clone(&self) -> Self {
        SharedVar { r: Rc::clone(&self.r) }
    }
}

impl<T: 'static> protected::Var<T> for SharedVar<T> {
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, T> {
        protected::BindInfo::Var(self.borrow(ctx.id()), self.r.is_new.get(), self.r.version.get())
    }

    fn read_only_prev_version(&self) -> u32 {
        self.r.version.get().wrapping_sub(1)
    }
}

impl<T: 'static> SizedVar<T> for SharedVar<T> {
    fn get(&self, ctx: &AppContext) -> &T {
        self.borrow(ctx.id())
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a T> {
        if self.r.is_new.get() {
            Some(self.get(ctx))
        } else {
            None
        }
    }

    fn is_new(&self, _: &AppContext) -> bool {
        self.r.is_new.get()
    }

    fn version(&self, _: &AppContext) -> u32 {
        self.r.version.get()
    }

    fn read_only(&self) -> bool {
        false
    }

    fn always_read_only(&self) -> bool {
        false
    }

    fn push_set(&self, new_value: T, ctx: &mut AppContext) -> Result<(), VarIsReadOnly> {
        let var = self.clone();
        let ctx_id = ctx.id();
        ctx.push_modify_impl(move |cleanup| {
            var.modify(ctx_id, move |v| *v = new_value, cleanup);
        });
        Ok(())
    }
}

impl<T: 'static> Var<T> for SharedVar<T> {
    type AsReadOnly = ReadOnlyVar<T, Self>;

    /// Schedules a variable modification for the next update.
    fn push_modify(&self, modify: impl FnOnce(&mut T) + 'static, ctx: &mut AppContext) -> Result<(), VarIsReadOnly> {
        let var = self.clone();
        let ctx_id = ctx.id();
        ctx.push_modify_impl(move |cleanup| {
            var.modify(ctx_id, modify, cleanup);
        });
        Ok(())
    }

    fn map<O: 'static, M: FnMut(&T) -> O + 'static>(&self, map: M) -> MapVar<T, Self, O, M> {
        MapVar::new(MapVarInner::Shared(MapSharedVar::new(
            self.clone(),
            map,
            self.r.version.get().wrapping_sub(1),
        )))
    }

    fn as_read_only(self) -> Self::AsReadOnly {
        ReadOnlyVar::new(self)
    }
}

/// A variable that is [always_read_only](Var::always_read_only).
///
/// This `struct` is created by the [as_read_only](Var::as_read_only) method in variables
/// that are not `always_read_only`.
pub struct ReadOnlyVar<T: 'static, V: Var<T> + Clone> {
    _t: PhantomData<T>,
    var: V,
}

impl<T: 'static, V: Var<T> + Clone> ReadOnlyVar<T, V> {
    fn new(var: V) -> Self {
        ReadOnlyVar { _t: PhantomData, var }
    }
}

impl<T: 'static, V: Var<T> + Clone> protected::Var<T> for ReadOnlyVar<T, V> {
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, T> {
        self.var.bind_info(ctx)
    }
}

impl<T: 'static, V: Var<T> + Clone> SizedVar<T> for ReadOnlyVar<T, V> {
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a T {
        self.var.get(ctx)
    }

    /// [get] if [is_new] or none.
    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a T> {
        self.var.update(ctx)
    }

    /// If the value changed this update.
    fn is_new(&self, ctx: &AppContext) -> bool {
        self.var.is_new(ctx)
    }

    /// Current value version. Version changes every time the value changes.
    fn version(&self, ctx: &AppContext) -> u32 {
        self.var.version(ctx)
    }
}

impl<T: 'static, V: Var<T> + Clone> Clone for ReadOnlyVar<T, V> {
    fn clone(&self) -> Self {
        ReadOnlyVar {
            _t: PhantomData,
            var: self.var.clone(),
        }
    }
}

impl<T: 'static, V: Var<T> + Clone> Var<T> for ReadOnlyVar<T, V> {
    type AsReadOnly = Self;

    fn map<O: 'static, M: FnMut(&T) -> O + 'static>(&self, map: M) -> MapVar<T, Self, O, M> {
        MapVar::new(MapVarInner::Shared(MapSharedVar::new(
            self.clone(),
            map,
            self.var.read_only_prev_version(),
        )))
    }

    fn as_read_only(self) -> Self {
        self
    }
}

enum MapVarInner<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> {
    Owned(OwnedVar<O>),
    Shared(MapSharedVar<T, S, O, M>),
    Context(MapContextVar<T, S, O, M>),
}

/// A variable that maps the value of another variable.
struct MapSharedVar<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> {
    _t: PhantomData<T>,
    source: S,
    map: RefCell<M>,
    output: UnsafeCell<MaybeUninit<O>>,
    output_version: Cell<u32>,
    context: AppContextOwnership,
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> MapSharedVar<T, S, O, M> {
    fn new(source: S, map: M, prev_version: u32) -> Self {
        MapSharedVar {
            _t: PhantomData,
            source,
            map: RefCell::new(map),
            output: UnsafeCell::new(MaybeUninit::uninit()),
            output_version: Cell::new(prev_version),
            context: AppContextOwnership::default(),
        }
    }

    fn borrow(&self, ctx: &AppContext) -> &O {
        self.context.check(
            ctx.id(),
            format_args!(
                "cannot borrow `MapVar<{}>` because it is already bound to a different `AppContext`",
                type_name::<T>()
            ),
        );

        let source_version = self.source.version(ctx);
        if self.output_version.get() != source_version {
            let value = (&mut *self.map.borrow_mut())(self.source.get(ctx));
            // SAFETY: This is safe because it only happens before the first borrow
            // of this update, and borrows cannot exist across updates because source
            // vars require a &mut AppContext for changing version.
            unsafe {
                let m_uninit = &mut *self.output.get();
                m_uninit.as_mut_ptr().write(value);
            }
            self.output_version.set(source_version);
        }

        // SAFETY:
        // borrow validation was done at the start of the method.
        // memory is initialized here because we start from the prev_version.
        unsafe {
            let inited = &*self.output.get();
            &*inited.as_ptr()
        }
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> protected::Var<O>
    for MapSharedVar<T, S, O, M>
{
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, O> {
        protected::BindInfo::Var(self.borrow(ctx), self.is_new(ctx), self.version(ctx))
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> SizedVar<O> for MapSharedVar<T, S, O, M> {
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a O {
        self.borrow(ctx)
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a O> {
        if self.is_new(ctx) {
            Some(self.borrow(ctx))
        } else {
            None
        }
    }

    fn is_new(&self, ctx: &AppContext) -> bool {
        self.source.is_new(ctx)
    }

    fn version(&self, ctx: &AppContext) -> u32 {
        self.source.version(ctx)
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> Var<O> for MapSharedVar<T, S, O, M> {
    type AsReadOnly = Self;

    fn map<O2: 'static, M2: FnMut(&O) -> O2 + 'static>(&self, _map: M2) -> MapVar<O, Self, O2, M2> {
        //MapVar::new(MapVarInner::Shared(MapSharedVar::new(self.clone(), map, self.output_version.get().wrapping_sub(1))))
        todo!("when GATs are stable")
    }

    fn as_read_only(self) -> Self {
        self
    }
}

type MapContextVarOutputs<O> = FnvHashMap<Option<WidgetId>, (UnsafeCell<O>, u32)>;

/// A variable that maps the value of a context variable.
struct MapContextVar<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> {
    _t: PhantomData<T>,
    source: S,
    map: RefCell<M>,
    outputs: RefCell<MapContextVarOutputs<O>>,
    context: AppContextOwnership,
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> MapContextVar<T, S, O, M> {
    fn new(source: S, map: M) -> Self {
        MapContextVar {
            _t: PhantomData,
            source,
            map: RefCell::new(map),
            outputs: RefCell::default(),
            context: AppContextOwnership::default(),
        }
    }

    fn borrow(&self, ctx: &AppContext) -> &O {
        self.context.check(
            ctx.id(),
            format_args!(
                "cannot borrow `MapVar<{}>` because it is already bound to a different `AppContext`",
                type_name::<T>()
            ),
        );

        use std::collections::hash_map::Entry::{Occupied, Vacant};
        let mut outputs = self.outputs.borrow_mut();
        let widget_id = ctx.try_widget_id();
        let source_version = self.source.version(ctx);

        let output = match outputs.entry(widget_id) {
            Occupied(entry) => {
                let (output, output_version) = entry.into_mut();
                if *output_version != source_version {
                    let value = (&mut *self.map.borrow_mut())(self.source.get(ctx));
                    // TODO UNSAFE: Same context var can be set twice in same widget.

                    // SAFETY: This is safe because it only happens before the first borrow
                    // of this update.
                    unsafe { *output.get() = value }
                    *output_version = source_version;
                }
                output
            }
            Vacant(entry) => {
                let value = (&mut *self.map.borrow_mut())(self.source.get(ctx));
                let (output, _) = entry.insert((UnsafeCell::new(value), source_version));
                output
            }
        };

        // SAFETY:
        // borrow validation was done at the start of the method.
        unsafe { &*output.get() }
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> protected::Var<O> for MapContextVar<T, S, O, M> {
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, O> {
        protected::BindInfo::Var(self.borrow(ctx), self.source.is_new(ctx), self.source.version(ctx))
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> SizedVar<O> for MapContextVar<T, S, O, M> {
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a O {
        self.borrow(ctx)
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a O> {
        if self.is_new(ctx) {
            Some(self.borrow(ctx))
        } else {
            None
        }
    }

    fn is_new(&self, ctx: &AppContext) -> bool {
        self.source.is_new(ctx)
    }

    fn version(&self, ctx: &AppContext) -> u32 {
        self.source.version(ctx)
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> Var<O> for MapContextVar<T, S, O, M> {
    type AsReadOnly = Self;

    fn map<O2: 'static, M2: FnMut(&O) -> O2 + 'static>(&self, _map: M2) -> MapVar<O, Self, O2, M2> {
        todo!("when GATs are stable")
    }

    fn as_read_only(self) -> Self {
        self
    }
}

/// A variable that maps the value of another variable.
///
/// This `struct` is created by the [map](Var::map) method and is a temporary adapter until
/// [GATs](https://github.com/rust-lang/rust/issues/44265) are stable.
pub struct MapVar<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> {
    r: Rc<MapVarInner<T, S, O, M>>,
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O> MapVar<T, S, O, M> {
    fn new(inner: MapVarInner<T, S, O, M>) -> Self {
        MapVar { r: Rc::new(inner) }
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> protected::Var<O> for MapVar<T, S, O, M> {
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, O> {
        match &*self.r {
            MapVarInner::Owned(o) => o.bind_info(ctx),
            MapVarInner::Shared(s) => s.bind_info(ctx),
            MapVarInner::Context(c) => c.bind_info(ctx),
        }
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> SizedVar<O> for MapVar<T, S, O, M> {
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a O {
        match &*self.r {
            MapVarInner::Owned(o) => o.get(ctx),
            MapVarInner::Shared(s) => s.get(ctx),
            MapVarInner::Context(c) => c.get(ctx),
        }
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a O> {
        match &*self.r {
            MapVarInner::Owned(o) => o.update(ctx),
            MapVarInner::Shared(s) => s.update(ctx),
            MapVarInner::Context(c) => c.update(ctx),
        }
    }

    fn is_new(&self, ctx: &AppContext) -> bool {
        match &*self.r {
            MapVarInner::Owned(o) => o.is_new(ctx),
            MapVarInner::Shared(s) => s.is_new(ctx),
            MapVarInner::Context(c) => c.is_new(ctx),
        }
    }

    fn version(&self, ctx: &AppContext) -> u32 {
        match &*self.r {
            MapVarInner::Owned(o) => o.version(ctx),
            MapVarInner::Shared(s) => s.version(ctx),
            MapVarInner::Context(c) => c.version(ctx),
        }
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> Clone for MapVar<T, S, O, M> {
    fn clone(&self) -> Self {
        MapVar { r: Rc::clone(&self.r) }
    }
}

impl<T: 'static, S: SizedVar<T>, O: 'static, M: FnMut(&T) -> O + 'static> Var<O> for MapVar<T, S, O, M> {
    type AsReadOnly = Self;

    fn map<O2: 'static, M2: FnMut(&O) -> O2 + 'static>(&self, map: M2) -> MapVar<O, Self, O2, M2> {
        MapVar::new(MapVarInner::Shared(MapSharedVar::new(self.clone(), map, 0)))
    }

    fn as_read_only(self) -> Self {
        self
    }
}

/// A variable that can be one of many variables at a time, determined by
/// a its index.
#[allow(clippy::len_without_is_empty)]
pub trait SwitchVar<T: 'static>: Var<T> + protected::SwitchVar<T> {
    /// Current variable index.
    fn index(&self) -> usize;

    /// Number of variables that can be indexed.
    fn len(&self) -> usize;
}

struct SwitchVar2Inner<T: 'static, V0: Var<T>, V1: Var<T>> {
    _t: PhantomData<T>,
    v0: V0,
    v1: V1,

    index: Cell<u8>,

    v0_version: Cell<u32>,
    v1_version: Cell<u32>,

    version: Cell<u32>,
    is_new: Cell<bool>,
}

pub struct SwitchVar2<T: 'static, V0: Var<T>, V1: Var<T>> {
    r: Rc<SwitchVar2Inner<T, V0, V1>>,
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> SwitchVar2<T, V0, V1> {
    pub fn new(index: u8, v0: V0, v1: V1, ctx: &AppContext) -> Self {
        assert!(index < 2);
        SwitchVar2 {
            r: Rc::new(SwitchVar2Inner {
                _t: PhantomData,
                index: Cell::new(index),
                v0_version: Cell::new(v0.version(ctx)),
                v1_version: Cell::new(v1.version(ctx)),
                version: Cell::new(0),
                is_new: Cell::new(false),
                v0,
                v1,
            }),
        }
    }
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> protected::Var<T> for SwitchVar2<T, V0, V1> {
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, T> {
        let is_new = self.is_new(ctx);
        let version = self.version(ctx);
        let inner_info = match self.r.index.get() {
            0 => self.r.v0.bind_info(ctx),
            1 => self.r.v1.bind_info(ctx),
            _ => unreachable!(),
        };

        match inner_info {
            protected::BindInfo::Var(value, _, _) => protected::BindInfo::Var(value, is_new, version),
            protected::BindInfo::ContextVar(var_id, default, _) => {
                protected::BindInfo::ContextVar(var_id, default, Some((is_new, version)))
            }
        }
    }

    fn read_only_prev_version(&self) -> u32 {
        self.r.version.get().wrapping_sub(1)
    }
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> SizedVar<T> for SwitchVar2<T, V0, V1> {
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a T {
        match self.r.index.get() {
            0 => self.r.v0.get(ctx),
            1 => self.r.v1.get(ctx),
            _ => unreachable!(),
        }
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a T> {
        if self.r.is_new.get() {
            Some(self.get(ctx))
        } else {
            match self.r.index.get() {
                0 => self.r.v0.update(ctx),
                1 => self.r.v1.update(ctx),
                _ => unreachable!(),
            }
        }
    }

    fn is_new(&self, ctx: &AppContext) -> bool {
        self.r.is_new.get()
            || match self.r.index.get() {
                0 => self.r.v0.is_new(ctx),
                1 => self.r.v1.is_new(ctx),
                _ => unreachable!(),
            }
    }

    fn version(&self, ctx: &AppContext) -> u32 {
        match self.r.index.get() {
            0 => {
                let v0_version = self.r.v0.version(ctx);
                if v0_version != self.r.v0_version.get() {
                    self.r.v0_version.set(v0_version);
                    self.r.version.set(self.r.version.get().wrapping_add(1));
                }
            }
            1 => {
                let v1_version = self.r.v1.version(ctx);
                if v1_version != self.r.v1_version.get() {
                    self.r.v1_version.set(v1_version);
                    self.r.version.set(self.r.version.get().wrapping_add(1));
                }
            }
            _ => unreachable!(),
        }
        self.r.version.get()
    }

    fn read_only(&self) -> bool {
        match self.r.index.get() {
            0 => self.r.v0.read_only(),
            1 => self.r.v1.read_only(),
            _ => unreachable!(),
        }
    }

    fn always_read_only(&self) -> bool {
        self.r.v0.always_read_only() && self.r.v1.always_read_only()
    }

    fn push_set(&self, new_value: T, ctx: &mut AppContext) -> Result<(), VarIsReadOnly> {
        match self.r.index.get() {
            0 => self.r.v0.push_set(new_value, ctx),
            1 => self.r.v1.push_set(new_value, ctx),
            _ => unreachable!(),
        }
    }
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> Clone for SwitchVar2<T, V0, V1> {
    fn clone(&self) -> Self {
        SwitchVar2 { r: Rc::clone(&self.r) }
    }
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> Var<T> for SwitchVar2<T, V0, V1> {
    type AsReadOnly = ReadOnlyVar<T, Self>;

    fn push_modify(&self, modify: impl FnOnce(&mut T) + 'static, ctx: &mut AppContext) -> Result<(), VarIsReadOnly> {
        match self.r.index.get() {
            0 => self.r.v0.push_modify(modify, ctx),
            1 => self.r.v1.push_modify(modify, ctx),
            _ => unreachable!(),
        }
    }

    fn map<O: 'static, M: FnMut(&T) -> O + 'static>(&self, map: M) -> MapVar<T, Self, O, M> {
        MapVar::new(MapVarInner::Shared(MapSharedVar::new(
            self.clone(),
            map,
            self.r.version.get().wrapping_sub(1),
        )))
    }

    fn as_read_only(self) -> Self::AsReadOnly {
        ReadOnlyVar::new(self)
    }
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> protected::SwitchVar<T> for SwitchVar2<T, V0, V1> {
    fn modify(self, new_index: usize, cleanup: &mut Vec<Box<dyn FnOnce()>>) {
        debug_assert!(new_index < 2);
        let new_index = new_index as u8;

        if new_index != self.r.index.get() {
            self.r.index.set(new_index as u8);
            self.r.is_new.set(true);
            self.r.version.set(self.r.version.get().wrapping_add(1));

            cleanup.push(Box::new(move || self.r.is_new.set(false)));
        }
    }
}

impl<T: 'static, V0: Var<T>, V1: Var<T>> SwitchVar<T> for SwitchVar2<T, V0, V1> {
    fn index(&self) -> usize {
        self.r.index.get() as usize
    }

    fn len(&self) -> usize {
        2
    }
}

struct MergeVar2Inner<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O> {
    _t0: PhantomData<T0>,
    _t1: PhantomData<T1>,
    v0: V0,
    v1: V1,
    v0_version: Cell<u32>,
    v1_version: Cell<u32>,
    merge: RefCell<M>,
    output: UnsafeCell<MaybeUninit<O>>,
    version: Cell<u32>,
    context: AppContextOwnership,
}

pub struct MergeVar2<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O> {
    r: Rc<MergeVar2Inner<T0, T1, V0, V1, O, M>>,
}

impl<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O>
    MergeVar2<T0, T1, V0, V1, O, M>
{
    pub fn new(v0: V0, v1: V1, merge: M) -> Self {
        MergeVar2 {
            r: Rc::new(MergeVar2Inner {
                _t0: PhantomData,
                _t1: PhantomData,
                v0_version: Cell::new(0), // TODO prev_version
                v1_version: Cell::new(0),
                v0,
                v1,
                merge: RefCell::new(merge),
                output: UnsafeCell::new(MaybeUninit::uninit()),
                version: Cell::new(0),
                context: AppContextOwnership::default(),
            }),
        }
    }

    fn borrow(&self, ctx: &AppContext) -> &O {
        todo!()
    }

    fn any_is_new(&self, ctx: &AppContext) -> bool {
        self.r.v0.is_new(ctx) | self.r.v1.is_new(ctx)
    }
}

impl<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O> Clone
    for MergeVar2<T0, T1, V0, V1, O, M>
{
    fn clone(&self) -> Self {
        MergeVar2 { r: Rc::clone(&self.r) }
    }
}

impl<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O> protected::Var<O>
    for MergeVar2<T0, T1, V0, V1, O, M>
{
    fn bind_info<'a, 'b>(&'a self, ctx: &'b AppContext) -> protected::BindInfo<'a, O> {
        protected::BindInfo::Var(self.borrow(ctx), self.any_is_new(ctx), self.r.version.get())
    }
}

impl<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O + 'static> SizedVar<O>
    for MergeVar2<T0, T1, V0, V1, O, M>
{
    fn get<'a>(&'a self, ctx: &'a AppContext) -> &'a O {
        self.borrow(ctx)
    }

    fn update<'a>(&'a self, ctx: &'a AppContext) -> Option<&'a O> {
        if self.any_is_new(ctx) {
            Some(self.borrow(ctx))
        } else {
            None
        }
    }

    fn is_new(&self, ctx: &AppContext) -> bool {
        self.any_is_new(ctx)
    }

    fn version(&self, ctx: &AppContext) -> u32 {
        self.r.version.get()
    }
}

impl<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O + 'static> Var<O>
    for MergeVar2<T0, T1, V0, V1, O, M>
{
    type AsReadOnly = Self;

    fn map<O2: 'static, M2: FnMut(&O) -> O2 + 'static>(&self, map: M2) -> MapVar<O, Self, O2, M2> {
        todo!()
    }

    fn as_read_only(self) -> Self {
        self
    }
}

//TODO map_bidi, merge

/// A value-to-[var](Var) conversion that consumes the value.
pub trait IntoVar<T: 'static> {
    type Var: Var<T> + 'static;

    fn into_var(self) -> Self::Var;
}

/// Already is var.
impl<T: 'static> IntoVar<T> for SharedVar<T> {
    type Var = Self;

    fn into_var(self) -> Self::Var {
        self
    }
}

/// Already is var.
impl<T: 'static, O: 'static, M: FnMut(&T) -> O + 'static, S: SizedVar<T>> IntoVar<O> for MapSharedVar<T, S, O, M> {
    type Var = Self;

    fn into_var(self) -> Self::Var {
        self
    }
}

/// Already is var.
impl<T: 'static, O: 'static, M: FnMut(&T) -> O + 'static, S: SizedVar<T>> IntoVar<O> for MapContextVar<T, S, O, M> {
    type Var = Self;

    fn into_var(self) -> Self::Var {
        self
    }
}

/// Already is var.
impl<T: 'static, O: 'static, M: FnMut(&T) -> O + 'static, S: SizedVar<T>> IntoVar<O> for MapVar<T, S, O, M> {
    type Var = Self;

    fn into_var(self) -> Self::Var {
        self
    }
}

/// Already is var.
impl<T: 'static, V0: Var<T>, V1: Var<T>> IntoVar<T> for SwitchVar2<T, V0, V1> {
    type Var = Self;

    fn into_var(self) -> Self::Var {
        self
    }
}

/// Already is var.
impl<T0: 'static, T1: 'static, V0: Var<T0>, V1: Var<T1>, O: 'static, M: FnMut(&T0, &T1) -> O + 'static> IntoVar<O>
    for MergeVar2<T0, T1, V0, V1, O, M>
{
    type Var = Self;

    fn into_var(self) -> Self::Var {
        self
    }
}

/// Wraps the value in an `[Owned]<T>` value.
impl<T: 'static> IntoVar<T> for T {
    type Var = OwnedVar<T>;

    fn into_var(self) -> OwnedVar<T> {
        OwnedVar(self)
    }
}
