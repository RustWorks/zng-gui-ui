//! Aggregate events.

use linear_map::{set::LinearSet, LinearMap};

use crate::{
    app::*,
    context::*,
    crate_util::{Handle, HandleOwner, WeakHandle},
    event::*,
    event::{Command, CommandMetaVar, CommandScope, StaticCommandMetaVarId},
    focus::{Focus, FocusRequest, FocusTarget},
    keyboard::*,
    mouse::*,
    service::Service,
    service::ServiceTuple,
    units::DipPoint,
    var::{impl_from_and_into_var, Var, Vars, WithVarsRead},
    widget_info::{HitTestInfo, InteractionPath},
    window::{WindowId, Windows},
    WidgetId, WidgetPath,
};
use std::{
    cell::RefCell,
    convert::{TryFrom, TryInto},
    fmt::{self, Display},
    mem,
    num::NonZeroU32,
    rc::Rc,
    time::{Duration, Instant},
};

/// Specific information from the source of a [`ClickArgs`].
#[derive(Debug, Clone)]
pub enum ClickArgsSource {
    /// Click event was generated by the [mouse click event](MouseClickEvent).
    Mouse {
        /// Which mouse button generated the event.
        button: MouseButton,

        /// Position of the mouse in the coordinates of [`target`](ClickArgs::target).
        position: DipPoint,

        /// Hit-test result for the mouse point in the window, at the moment the click event
        /// was generated.
        hits: HitTestInfo,
    },

    /// Click event was generated by the [shortcut event](ShortcutEvent).
    Shortcut {
        /// The shortcut.
        shortcut: Shortcut,
        /// If the shortcut event was generated by holding a key pressed.
        is_repeat: bool,
        /// Kind of click represented by the `shortcut`.
        kind: ShortcutClick,
    },
}

/// What kind of click a shortcut represents in a [`ClickArgsSource::Shortcut`].
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ShortcutClick {
    /// The shortcut represents a primary click on the focused widget.
    Primary,
    /// The shortcut represents a context click on the focused widget.
    Context,
}

event_args! {
    /// [`CLICK_EVENT`] arguments.
    pub struct ClickArgs {
        /// Id of window that received the event.
        pub window_id: WindowId,

        /// Id of device that generated the event.
        ///
        /// Is `None` if the event was generated programmatically.
        pub device_id: Option<DeviceId>,

        /// Specific info from the source of this event.
        pub source: ClickArgsSource,

        /// Sequential click count. Number `1` is single click, `2` is double click, etc.
        ///
        /// This is always `1` for clicks initiated by the keyboard.
        pub click_count: NonZeroU32,

        /// What modifier keys where pressed when this event happened.
        pub modifiers: ModifiersState,

        /// The mouse input top-most hit or the focused element at the time of the key input.
        pub target: InteractionPath,

        ..

        /// The [`target`].
        ///
        /// [`target`]: Self::target
        fn delivery_list(&self) -> EventDeliveryList {
            EventDeliveryList::widgets(&self.target)
        }
    }

    /// [`SHORTCUT_EVENT`] arguments.
    pub struct ShortcutArgs {
        /// Id of window that received the event.
        pub window_id: WindowId,

        /// Id of device that generated the event.
        ///
        /// Is `None` if the event was generated programmatically.
        pub device_id: Option<DeviceId>,

        /// The shortcut.
        pub shortcut: Shortcut,

        /// If the event was generated by holding the key pressed.
        pub is_repeat: bool,

        /// Actions that will run if this event propagation is not stopped.
        pub actions: ShortcutActions,

        ..

        /// No target, only app extensions.
        fn delivery_list(&self) -> EventDeliveryList {
            EventDeliveryList::none()
        }
    }
}

impl From<MouseClickArgs> for ClickArgs {
    fn from(args: MouseClickArgs) -> Self {
        ClickArgs::new(
            args.timestamp,
            args.propagation().clone(),
            args.window_id,
            args.device_id,
            ClickArgsSource::Mouse {
                button: args.button,
                position: args.position,
                hits: args.hits,
            },
            args.click_count,
            args.modifiers,
            args.target,
        )
    }
}
impl ClickArgs {
    /// Returns `true` if the widget is enabled in [`target`].
    ///
    /// [`target`]: Self::target
    pub fn is_enabled(&self, widget_id: WidgetId) -> bool {
        self.target.interactivity_of(widget_id).map(|i| i.is_enabled()).unwrap_or(false)
    }

    /// Returns `true` if the widget is disabled in [`target`].
    ///
    /// [`target`]: Self::target
    pub fn is_disabled(&self, widget_id: WidgetId) -> bool {
        self.target.interactivity_of(widget_id).map(|i| i.is_disabled()).unwrap_or(false)
    }

    /// If the event counts as *primary* click.
    ///
    /// A primary click causes the default widget function interaction.
    ///
    /// Returns `true` if the click source is a left mouse button click or a
    /// [primary click shortcut](Gestures::click_focused).
    pub fn is_primary(&self) -> bool {
        match &self.source {
            ClickArgsSource::Mouse { button, .. } => *button == MouseButton::Left,
            ClickArgsSource::Shortcut { kind, .. } => *kind == ShortcutClick::Primary,
        }
    }

    /// If the event counts as a *context menu* request.
    ///
    /// Returns `true` if the [`click_count`](Self::click_count) is `1` and the
    /// click source is a right mouse button click or a [context click shortcut](Gestures::context_click_focused).
    pub fn is_context(&self) -> bool {
        self.click_count.get() == 1
            && match &self.source {
                ClickArgsSource::Mouse { button, .. } => *button == MouseButton::Right,
                ClickArgsSource::Shortcut { kind, is_repeat, .. } => *kind == ShortcutClick::Context && !is_repeat,
            }
    }

    /// If the event was caused by a press of `mouse_button`.
    pub fn is_mouse_btn(&self, mouse_button: MouseButton) -> bool {
        match &self.source {
            ClickArgsSource::Mouse { button, .. } => *button == mouse_button,
            ClickArgsSource::Shortcut { .. } => false,
        }
    }

    /// If the event was generated by holding a keyboard key pressed.
    pub fn is_repeat(&self) -> bool {
        match &self.source {
            ClickArgsSource::Shortcut { is_repeat, .. } => *is_repeat,
            ClickArgsSource::Mouse { .. } => false,
        }
    }

    /// The shortcut the generated this event.
    pub fn shortcut(&self) -> Option<Shortcut> {
        match &self.source {
            ClickArgsSource::Shortcut { shortcut, .. } => Some(*shortcut),
            ClickArgsSource::Mouse { .. } => None,
        }
    }

    /// If the [`click_count`](Self::click_count) is `1`.
    pub fn is_single(&self) -> bool {
        self.click_count.get() == 1
    }

    /// If the [`click_count`](Self::click_count) is `2`.
    pub fn is_double(&self) -> bool {
        self.click_count.get() == 2
    }

    /// If the [`click_count`](Self::click_count) is `3`.
    pub fn is_triple(&self) -> bool {
        self.click_count.get() == 3
    }

    /// If this event was generated by a mouse device.
    pub fn is_from_mouse(&self) -> bool {
        matches!(&self.source, ClickArgsSource::Mouse { .. })
    }

    /// If this event was generated by a keyboard device.
    pub fn is_from_keyboard(&self) -> bool {
        matches!(&self.source, ClickArgsSource::Shortcut { .. })
    }
}

/// A keyboard combination.
#[derive(Clone, Copy)]
pub struct KeyGesture {
    /// The key modifiers.
    ///
    /// Equality of key gestures matches the [`ambit`] modifiers, so a `L_CTRL` is equal to a `R_CTRL` in a key gesture,
    /// the actual bit flag is preserved in the state and can be extracted from the shortcut.
    ///
    /// [`ambit`]: ModifiersState::ambit
    pub modifiers: ModifiersState,
    /// The key.
    pub key: GestureKey,
}
impl PartialEq for KeyGesture {
    fn eq(&self, other: &Self) -> bool {
        self.modifiers.ambit() == other.modifiers.ambit() && self.key == other.key
    }
}
impl Eq for KeyGesture {}
impl std::hash::Hash for KeyGesture {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.modifiers.ambit().hash(state);
        self.key.hash(state);
    }
}
impl KeyGesture {
    #[allow(missing_docs)]
    pub fn new(modifiers: ModifiersState, key: GestureKey) -> Self {
        KeyGesture { modifiers, key }
    }

    /// New key gesture without modifiers.
    pub fn new_key(key: GestureKey) -> Self {
        KeyGesture {
            modifiers: ModifiersState::empty(),
            key,
        }
    }
}
impl fmt::Debug for KeyGesture {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            f.debug_struct("KeyGesture")
                .field("modifiers", &self.modifiers)
                .field("key", &self.key)
                .finish()
        } else {
            write!(f, "{self}")
        }
    }
}
impl Display for KeyGesture {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.modifiers.has_logo() {
            write!(f, "Logo+")?
        }
        if self.modifiers.has_ctrl() {
            write!(f, "Ctrl+")?
        }
        if self.modifiers.has_shift() {
            write!(f, "Shift+")?
        }
        if self.modifiers.has_alt() {
            write!(f, "Alt+")?
        }

        write!(f, "{}", self.key)
    }
}

/// A modifier key press and release without any other key press in between.
#[derive(Clone, Copy, Eq, PartialEq, Hash)]
pub enum ModifierGesture {
    /// Any of the Windows/Apple keys.
    Logo,
    /// Any of the CTRL keys.
    Ctrl,
    /// Any of the SHIFT keys.
    Shift,
    /// Any of the ALT keys.
    Alt,
}
impl fmt::Debug for ModifierGesture {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            write!(f, "ModifierGesture::")?;
        }
        write!(f, "{self}")
    }
}
impl Display for ModifierGesture {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ModifierGesture::Logo => write!(f, "Logo"),
            ModifierGesture::Ctrl => write!(f, "Ctrl"),
            ModifierGesture::Shift => write!(f, "Shift"),
            ModifierGesture::Alt => write!(f, "Alt"),
        }
    }
}
impl TryFrom<Key> for ModifierGesture {
    type Error = Key;
    fn try_from(value: Key) -> Result<Self, Self::Error> {
        match value {
            Key::LAlt | Key::RAlt => Ok(ModifierGesture::Alt),
            Key::LCtrl | Key::RCtrl => Ok(ModifierGesture::Ctrl),
            Key::LShift | Key::RShift => Ok(ModifierGesture::Shift),
            Key::LLogo | Key::RLogo => Ok(ModifierGesture::Logo),
            key => Err(key),
        }
    }
}
impl ModifierGesture {
    fn left_key(&self) -> Key {
        match self {
            ModifierGesture::Logo => Key::LLogo,
            ModifierGesture::Ctrl => Key::LCtrl,
            ModifierGesture::Shift => Key::LShift,
            ModifierGesture::Alt => Key::LAlt,
        }
    }
    fn modifiers_state(&self) -> ModifiersState {
        match self {
            ModifierGesture::Logo => ModifiersState::LOGO,
            ModifierGesture::Ctrl => ModifiersState::CTRL,
            ModifierGesture::Shift => ModifiersState::SHIFT,
            ModifierGesture::Alt => ModifiersState::ALT,
        }
    }
}

/// A sequence of two keyboard combinations.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct KeyChord {
    /// The first key gesture.
    pub starter: KeyGesture,

    /// The second key gesture.
    pub complement: KeyGesture,
}
impl fmt::Debug for KeyChord {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            f.debug_struct("KeyChord")
                .field("starter", &self.starter)
                .field("complement", &self.complement)
                .finish()
        } else {
            write!(f, "{self}")
        }
    }
}
impl Display for KeyChord {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} {}", self.starter, self.complement)
    }
}

/// Keyboard gesture or chord associated with a command.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum Shortcut {
    /// Key-press plus modifiers.
    Gesture(KeyGesture),
    /// Sequence of two key gestures.
    Chord(KeyChord),
    /// Modifier press and release.
    Modifier(ModifierGesture),
}
impl fmt::Debug for Shortcut {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            match self {
                Shortcut::Gesture(g) => f.debug_tuple("Shortcut::Gesture").field(g).finish(),
                Shortcut::Chord(c) => f.debug_tuple("Shortcut::Chord").field(c).finish(),
                Shortcut::Modifier(m) => f.debug_tuple("Shortcut::Modifier").field(m).finish(),
            }
        } else {
            write!(f, "{self}")
        }
    }
}
impl Display for Shortcut {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Shortcut::Gesture(g) => Display::fmt(g, f),
            Shortcut::Chord(c) => Display::fmt(c, f),
            Shortcut::Modifier(m) => Display::fmt(m, f),
        }
    }
}
impl Shortcut {
    fn modifiers_state(&self) -> ModifiersState {
        match self {
            Shortcut::Gesture(g) => g.modifiers,
            Shortcut::Chord(c) => c.complement.modifiers,
            Shortcut::Modifier(m) => m.modifiers_state(),
        }
    }
}
impl_from_and_into_var! {
    fn from(shortcut: Shortcut) -> Shortcuts {
        Shortcuts(vec![shortcut])
    }

    fn from(key_gesture: KeyGesture) -> Shortcut {
        Shortcut::Gesture(key_gesture)
    }

    fn from(key_chord: KeyChord) -> Shortcut {
        Shortcut::Chord(key_chord)
    }

    fn from(modifier: ModifierGesture) -> Shortcut {
        Shortcut::Modifier(modifier)
    }

    fn from(gesture_key: GestureKey) -> Shortcut {
        KeyGesture::new_key(gesture_key).into()
    }

    fn from(gesture_key: GestureKey) -> Shortcuts {
        Shortcuts(vec![gesture_key.into()])
    }

    fn from(key_gesture: KeyGesture) -> Shortcuts {
        Shortcuts(vec![key_gesture.into()])
    }

    fn from(key_chord: KeyChord) -> Shortcuts {
        Shortcuts(vec![key_chord.into()])
    }

    fn from(modifier: ModifierGesture) -> Shortcuts {
        Shortcuts(vec![modifier.into()])
    }

    fn from(shortcuts: Vec<Shortcut>) -> Shortcuts {
        Shortcuts(shortcuts)
    }
}
impl<const N: usize> From<[Shortcut; N]> for Shortcuts {
    fn from(a: [Shortcut; N]) -> Self {
        Shortcuts(a.into())
    }
}
impl<const N: usize> crate::var::IntoVar<Shortcuts> for [Shortcut; N] {
    type Var = crate::var::LocalVar<Shortcuts>;

    fn into_var(self) -> Self::Var {
        crate::var::LocalVar(self.into())
    }
}

/// Multiple shortcuts.
#[derive(Default, Clone)]
pub struct Shortcuts(pub Vec<Shortcut>);
impl Shortcuts {
    /// New default (empty).
    pub fn new() -> Self {
        Self::default()
    }

    /// Try to generate shortcuts that produce the `character`.
    ///
    /// Returns at least one shortcut or error the char back if it cannot
    /// be generated by a single shortcut.
    ///
    /// Note chords are not generated. Caps lock is assumed to be off.
    pub fn from_char(character: char) -> Result<Self, char> {
        let char_range_to_key = |char0: char, key0: GestureKey| {
            // SAFETY: this is safe if the char range matches the key range,
            // which we verified for all cases.
            let key: GestureKey = unsafe { mem::transmute(key0 as u32 + (character as u8 - char0 as u8) as u32) };
            key
        };

        match character {
            'a'..='z' => {
                let key = char_range_to_key('a', GestureKey::A);
                Ok(key.into())
            }
            'A'..='Z' => {
                let key = char_range_to_key('A', GestureKey::A);
                let gesture = KeyGesture::new(ModifiersState::SHIFT, key);
                Ok(gesture.into())
            }
            '1'..='9' => {
                let key = char_range_to_key('1', GestureKey::Key1);
                let num_key = char_range_to_key('1', GestureKey::Numpad1);
                Ok(Shortcuts(vec![key.into(), num_key.into()]))
            }
            '0' => Ok(Shortcuts(vec![GestureKey::Key0.into(), GestureKey::Numpad0.into()])),
            '+' => Ok(Shortcuts(vec![GestureKey::Plus.into(), GestureKey::NumpadAdd.into()])),
            '-' => Ok(Shortcuts(vec![GestureKey::Minus.into(), GestureKey::NumpadSubtract.into()])),
            '*' => Ok(Shortcuts(vec![GestureKey::Asterisk.into(), GestureKey::NumpadMultiply.into()])),
            '/' => Ok(Shortcuts(vec![GestureKey::Slash.into(), GestureKey::NumpadDivide.into()])),
            '.' => Ok(GestureKey::Period.into()),
            _ => Err(character),
        }
    }

    /// If the `shortcut` is present in the shortcuts.
    pub fn contains(&self, shortcut: Shortcut) -> bool {
        self.0.contains(&shortcut)
    }
}
impl TryFrom<char> for Shortcuts {
    type Error = char;

    /// See [`from_char`](Self::from_char).
    fn try_from(value: char) -> Result<Self, Self::Error> {
        Shortcuts::from_char(value)
    }
}
impl fmt::Debug for Shortcuts {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            f.debug_tuple("Shortcuts").field(&self.0).finish()
        } else {
            write!(f, "[")?;
            if !self.0.is_empty() {
                if let Shortcut::Chord(c) = self.0[0] {
                    write!(f, "({c:?})")?;
                } else {
                    write!(f, "{:?}", self.0[0])?;
                }
                for shortcut in &self.0[1..] {
                    if let Shortcut::Chord(c) = shortcut {
                        write!(f, ", ({c:?})")?;
                    } else {
                        write!(f, ", {shortcut:?}")?;
                    }
                }
            }
            write!(f, "]")
        }
    }
}
impl fmt::Display for Shortcuts {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if !self.0.is_empty() {
            write!(f, "{}", self.0[0])?;
            for shortcut in &self.0[1..] {
                write!(f, " | {shortcut}")?;
            }
        }
        Ok(())
    }
}
impl std::ops::Deref for Shortcuts {
    type Target = Vec<Shortcut>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl std::ops::DerefMut for Shortcuts {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl KeyInputArgs {
    /// Key gesture this key press triggers.
    ///
    /// See also [`Gestures`].
    pub fn gesture(&self) -> Option<KeyGesture> {
        if self.state == KeyState::Released {
            return None;
        }

        self.key.and_then(|k| k.try_into().ok()).map(|key| KeyGesture {
            key,
            modifiers: self.modifiers,
        })
    }

    /// Gets [`gesture`](Self::gesture) as a shortcut.
    ///
    /// See also [`Gestures`].
    pub fn shortcut(&self) -> Option<Shortcut> {
        self.gesture().map(Shortcut::Gesture)
    }
}

#[doc(hidden)]
#[macro_export]
macro_rules! __shortcut {
    (-> + $Key:ident) => {
        $crate::gesture::KeyGesture {
            key: $crate::gesture::GestureKey::$Key,
            modifiers: $crate::keyboard::ModifiersState::empty(),
        }
    };

    (-> $($MODIFIER:ident)|+ + $Key:ident) => {
        $crate::gesture::KeyGesture {
            key: $crate::gesture::GestureKey::$Key,
            modifiers: $($crate::keyboard::ModifiersState::$MODIFIER)|+,
        }
    };

    (=> $($STARTER_MODIFIER:ident)|* + $StarterKey:ident, $($COMPLEMENT_MODIFIER:ident)|* + $ComplementKey:ident) => {
        $crate::gesture::KeyChord {
            starter: $crate::__shortcut!(-> $($STARTER_MODIFIER)|* + $StarterKey),
            complement: $crate::__shortcut!(-> $($COMPLEMENT_MODIFIER)|* + $ComplementKey)
        }
    };
}

///<span data-del-macro-root></span> Creates a [`Shortcut`](crate::gesture::Shortcut).
///
/// # Examples
///
/// ```
/// use zero_ui_core::gesture::{Shortcut, shortcut};
///
/// fn single_key() -> Shortcut {
///     shortcut!(Enter)
/// }
///
/// fn modified_key() -> Shortcut {
///     shortcut!(CTRL+C)
/// }
///
/// fn multi_modified_key() -> Shortcut {
///     shortcut!(CTRL|SHIFT+C)
/// }
///
/// fn chord() -> Shortcut {
///     shortcut!(CTRL+E, A)
/// }
///
/// fn modifier_release() -> Shortcut {
///     shortcut!(Alt)
/// }
/// ```
#[macro_export]
macro_rules! shortcut {
    (Logo) => {
        $crate::gesture::Shortcut::Modifier($crate::gesture::ModifierGesture::Logo)
    };
    (Shift) => {
        $crate::gesture::Shortcut::Modifier($crate::gesture::ModifierGesture::Shift)
    };
    (Ctrl) => {
        $crate::gesture::Shortcut::Modifier($crate::gesture::ModifierGesture::Ctrl)
    };
    (Alt) => {
        $crate::gesture::Shortcut::Modifier($crate::gesture::ModifierGesture::Alt)
    };

    ($Key:ident) => {
        $crate::gesture::Shortcut::Gesture($crate::__shortcut!(-> + $Key))
    };
    ($($MODIFIER:ident)|+ + $Key:ident) => {
        $crate::gesture::Shortcut::Gesture($crate::__shortcut!(-> $($MODIFIER)|+ + $Key))
    };

    ($StarterKey:ident, $ComplementKey:ident) => {
        $crate::gesture::Shortcut::Chord($crate::__shortcut!(=>
            + $StarterKey,
            + $ComplementKey
        ))
    };

    ($StarterKey:ident, $($COMPLEMENT_MODIFIER:ident)|+ + $ComplementKey:ident) => {
        $crate::gesture::Shortcut::Chord($crate::__shortcut!(=>
            + $StarterKey,
            $(COMPLEMENT_MODIFIER)|* + $ComplementKey
        ))
    };

    ($($STARTER_MODIFIER:ident)|+ + $StarterKey:ident, $ComplementKey:ident) => {
        $crate::gesture::Shortcut::Chord($crate::__shortcut!(=>
            $($STARTER_MODIFIER)|* + $StarterKey,
            + $ComplementKey
        ))
    };

    ($($STARTER_MODIFIER:ident)|+ + $StarterKey:ident, $($COMPLEMENT_MODIFIER:ident)|+ + $ComplementKey:ident) => {
        $crate::gesture::Shortcut::Chord($crate::__shortcut!(=>
            $($STARTER_MODIFIER)|* + $StarterKey,
            $($COMPLEMENT_MODIFIER)|* + $ComplementKey
        ))
    };
}
#[doc(inline)]
pub use crate::shortcut;

event! {
    /// Aggregate click event.
    ///
    /// Can be a mouse click, a shortcut press or a touch tap.
    pub static CLICK_EVENT: ClickArgs;

    /// Shortcut input event.
    ///
    /// Event happens every time a full [`Shortcut`] is completed by key press.
    ///
    /// This event is not send to any widget, use the [`Gestures`] service to setup widget targets for shortcuts.
    pub static SHORTCUT_EVENT: ShortcutArgs;
}

/// Application extension that provides aggregate events.
///
/// Events this extension provides.
///
/// * [ClickEvent]
/// * [ShortcutEvent]
///
/// Services this extension provides.
///
/// * [Gestures]
#[derive(Default)]
pub struct GestureManager {}
impl AppExtension for GestureManager {
    fn init(&mut self, r: &mut AppContext) {
        r.services.register(Gestures::new());
    }

    fn event(&mut self, ctx: &mut AppContext, update: &EventUpdate) {
        if let Some(args) = MOUSE_CLICK_EVENT.on(update) {
            // Generate click events from mouse clicks.
            if !args.propagation().is_stopped() {
                CLICK_EVENT.notify(ctx.events, args.clone().into());
            }
        } else if let Some(args) = KEY_INPUT_EVENT.on(update) {
            // Generate shortcut events from keyboard input.
            let (gestures, windows, focus) = <(Gestures, Windows, Focus)>::req(ctx.services);
            gestures.on_key_input(ctx.vars, ctx.events, focus, windows, args);
        } else if let Some(args) = SHORTCUT_EVENT.on(update) {
            // Run shortcut actions.
            let (gestures, focus) = <(Gestures, Focus)>::req(ctx.services);
            gestures.on_shortcut(ctx.events, focus, args);
        }
    }
}

/// Gesture events configuration.
///
/// # Shortcuts
///
/// This service coordinates shortcut associations with widgets and commands. To define a command's shortcut use
/// the [`CommandShortcutExt`] methods. To define the shortcut that *focus* and *clicks* a widget use [`click_shortcut`].
/// To define the shortcut that only focuses on a widget use [`focus_shortcut`]. To define a custom handle for a shortcut
/// use [`on_pre_event`] or [`on_event`] with the [`ShortcutEvent`].
///
/// ## Event Order
///
/// The same shortcut can end-up registered for multiple targets, activation of a shortcut causes these effects in this order:
///
/// 0. The gestures manager receives a [`KeyInputEvent`] in the [`event`] track, if a shortcut is completed it gets combined with
///    any primed chords and become the shortcut that will cause the following actions:
///
/// 1. The click, command and focus shortcuts are resolved in this order:
///
///    **First exclusively**:
///    
///    * Primary [`click_shortcut`] targeting a widget that is enabled and focused.
///    * Command scoped in a widget that is enabled and focused.
///    * Contextual [`click_shortcut`] targeting a widget that is enabled and focused.
///    * Primary [`click_shortcut`] targeting a widget that is enabled.
///    * Command scoped in a widget that is enabled.
///    * Contextual [`click_shortcut`] targeting a widget that is enabled.
///    * [`focus_shortcut`] targeting a widget that is enabled.
///    * The [`click_focused`] and [`context_click_focused`].
///    * *Same as the above, but for disabled widgets*
///
///     **And then:**
///
///    a. All enabled commands targeting the focused window.
///
///    b. All enabled commands targeting the app.
///
/// 2. The app level [`ShortcutEvent`] is notified, with the list of actions that will run, app extensions can handle it before [`event`]
///    to stop the resolved actions.
///
/// 3. The gestures manager receives the shortcut in [`event`], if propagation is not stopped and it contains any actions they are run,
///    the click and command events are linked by the same propagation. If the shortcut contains no action and it
///
/// 3. If the shortcut is a [`KeyChord::starter`] for one of the registered shortcuts, and was not claimed by
///     any of the above, the chord starter is primed for the next shortcut press.
///
/// The event propagation flag of shortcut, click and command events are linked, so stopping [`propagation`] in one signal
/// all others.
///
/// [`click_focused`]: Self::click_focused
/// [`context_click_focused`]: Self::context_click_focused
/// [`click_shortcut`]: Self::click_shortcut
/// [`focus_shortcut`]: Self::focus_shortcut
/// [`on_pre_event`]: Events::on_pre_event
/// [`on_event`]: Events::on_event
/// [`BLOCKED`]: crate::widget_info::Interactivity::BLOCKED
/// [`propagation`]: EventArgs::propagation
/// [`event_preview`]: AppExtension::event_preview
/// [`event_ui`]: AppExtension::event_ui
/// [`event`]: AppExtension::event
/// [`propagation`]: EventArgs::propagation
#[derive(Service)]
pub struct Gestures {
    /// Shortcuts that generate a primary [`ClickEvent`] for the focused widget.
    /// The shortcut only works if no widget or command claims it.
    ///
    /// Clicks generated by this shortcut count as [primary](ClickArgs::is_primary).
    ///
    /// Initial shortcuts are [`Enter`](Key::Enter) and [`Space`](Key::Space).
    pub click_focused: Shortcuts,

    /// Shortcuts that generate a context [`ClickEvent`] for the focused widget.
    /// The shortcut only works if no widget or command claims it.
    ///
    /// Clicks generated by this shortcut count as [context](ClickArgs::is_context).
    ///
    /// Initial shortcut is [`Apps`](Key::Apps).
    pub context_click_focused: Shortcuts,

    /// When a shortcut primary click happens, targeted widgets can indicate that
    /// they are pressed for this duration.
    ///
    /// Initial value is `50ms`, set to to `0` to deactivate this type of indication.
    pub shortcut_pressed_duration: Duration,

    pressed_modifier: Option<(WindowId, ModifierGesture)>,
    primed_starter: Option<KeyGesture>,
    chords: LinearMap<KeyGesture, LinearSet<KeyGesture>>,

    primary_clicks: Vec<(Shortcut, Rc<ShortcutTarget>)>,
    context_clicks: Vec<(Shortcut, Rc<ShortcutTarget>)>,
    focus: Vec<(Shortcut, Rc<ShortcutTarget>)>,
}
struct ShortcutTarget {
    widget_id: WidgetId,
    last_found: RefCell<Option<WidgetPath>>,
    handle: HandleOwner<()>,
}
impl ShortcutTarget {
    fn resolve_path(&self, windows: &mut Windows) -> Option<InteractionPath> {
        let mut found = self.last_found.borrow_mut();
        if let Some(found) = &mut *found {
            if let Ok(tree) = windows.widget_tree(found.window_id()) {
                if let Some(w) = tree.get(found.widget_id()) {
                    let path = w.interaction_path();
                    *found = path.as_path().clone();

                    return path.unblocked();
                }
            }
        }

        for tree in windows.widget_trees() {
            if let Some(w) = tree.get(self.widget_id) {
                let path = w.interaction_path();
                *found = Some(path.as_path().clone());

                return path.unblocked();
            }
        }

        None
    }
}
impl Gestures {
    fn new() -> Self {
        Gestures {
            click_focused: [shortcut!(Enter), shortcut!(Space)].into(),
            context_click_focused: [shortcut!(Apps)].into(),
            shortcut_pressed_duration: Duration::from_millis(50),

            pressed_modifier: None,
            primed_starter: None,
            chords: LinearMap::new(),

            primary_clicks: vec![],
            context_clicks: vec![],
            focus: vec![],
        }
    }

    /// Register a widget to receive shortcut clicks when any of the `shortcuts` are pressed.
    pub fn click_shortcut(&mut self, shortcuts: impl Into<Shortcuts>, kind: ShortcutClick, target: WidgetId) -> ShortcutsHandle {
        self.register_target(shortcuts.into(), Some(kind), target)
    }

    /// Register a widget to receive keyboard focus when any of the `shortcuts` are pressed.
    ///
    /// If the widget is not focusable the focus moves to the first focusable descendant or the first focusable ancestor.
    pub fn focus_shortcut(&mut self, shortcuts: impl Into<Shortcuts>, target: WidgetId) -> ShortcutsHandle {
        self.register_target(shortcuts.into(), None, target)
    }

    fn register_target(&mut self, shortcuts: Shortcuts, kind: Option<ShortcutClick>, target: WidgetId) -> ShortcutsHandle {
        if shortcuts.is_empty() {
            return ShortcutsHandle::dummy();
        }

        let (owner, handle) = ShortcutsHandle::new();
        let target = Rc::new(ShortcutTarget {
            widget_id: target,
            last_found: RefCell::new(None),
            handle: owner,
        });

        let collection = match kind {
            Some(ShortcutClick::Primary) => &mut self.primary_clicks,
            Some(ShortcutClick::Context) => &mut self.context_clicks,
            None => &mut self.focus,
        };

        if collection.len() > 500 {
            collection.retain(|(_, e)| !e.handle.is_dropped());
        }

        for s in shortcuts.0 {
            if let Shortcut::Chord(c) = &s {
                self.chords.entry(c.starter).or_insert_with(LinearSet::default).insert(c.complement);
            }

            collection.push((s, target.clone()));
        }

        handle
    }

    /// Gets all the event notifications that are send if the `shortcut` was pressed at this moment.
    ///
    /// See the [struct] level docs for details of how shortcut targets are resolved.
    ///
    /// [struct]: Self
    pub fn shortcut_actions(
        &mut self,
        vars: &Vars,
        events: &mut Events,
        focus: &mut Focus,
        windows: &mut Windows,
        shortcut: Shortcut,
    ) -> ShortcutActions {
        ShortcutActions::new(vars, events, self, focus, windows, shortcut)
    }

    fn on_key_input(&mut self, vars: &Vars, events: &mut Events, focus: &mut Focus, windows: &mut Windows, args: &KeyInputArgs) {
        if let (false, Some(key)) = (args.propagation().is_stopped(), args.key) {
            match args.state {
                KeyState::Pressed => {
                    if let Ok(gesture_key) = GestureKey::try_from(key) {
                        self.on_shortcut_pressed(
                            vars,
                            events,
                            focus,
                            windows,
                            Shortcut::Gesture(KeyGesture::new(args.modifiers, gesture_key)),
                            args,
                        );
                        self.pressed_modifier = None;
                    } else if let Ok(mod_gesture) = ModifierGesture::try_from(key) {
                        if !args.is_repeat {
                            self.pressed_modifier = Some((args.target.window_id(), mod_gesture));
                        }
                    } else {
                        self.pressed_modifier = None;
                        self.primed_starter = None;
                    }
                }
                KeyState::Released => {
                    if let Ok(mod_gesture) = ModifierGesture::try_from(key) {
                        if let (Some((window_id, gesture)), true) = (self.pressed_modifier.take(), args.modifiers.is_empty()) {
                            if window_id == args.target.window_id() && mod_gesture == gesture {
                                self.on_shortcut_pressed(vars, events, focus, windows, Shortcut::Modifier(mod_gesture), args);
                            }
                        }
                    }
                }
            }
        } else {
            // Scancode only or already handled.
            self.primed_starter = None;
            self.pressed_modifier = None;
        }
    }
    fn on_shortcut_pressed(
        &mut self,
        vars: &Vars,
        events: &mut Events,
        focus: &mut Focus,
        windows: &mut Windows,
        mut shortcut: Shortcut,
        key_args: &KeyInputArgs,
    ) {
        if let Some(starter) = self.primed_starter.take() {
            if let Shortcut::Gesture(g) = &shortcut {
                if let Some(complements) = self.chords.get(&starter) {
                    if complements.contains(g) {
                        shortcut = Shortcut::Chord(KeyChord { starter, complement: *g });
                    }
                }
            }
        }

        let actions = ShortcutActions::new(vars, events, self, focus, windows, shortcut);

        SHORTCUT_EVENT.notify(
            events,
            ShortcutArgs::new(
                key_args.timestamp,
                key_args.propagation().clone(),
                key_args.window_id,
                key_args.device_id,
                shortcut,
                key_args.is_repeat,
                actions,
            ),
        );
    }

    fn on_shortcut(&mut self, events: &mut Events, focus: &mut Focus, args: &ShortcutArgs) {
        if args.actions.has_actions() {
            args.actions
                .run(events, focus, args.timestamp, args.propagation(), args.device_id, args.is_repeat);
        } else if let Shortcut::Gesture(k) = args.shortcut {
            if self.chords.contains_key(&k) {
                self.primed_starter = Some(k);
            }
        }
    }

    fn cleanup(&mut self) {
        self.primary_clicks.retain(|(_, e)| !e.handle.is_dropped());
        self.context_clicks.retain(|(_, e)| !e.handle.is_dropped());
        self.focus.retain(|(_, e)| !e.handle.is_dropped());
    }
}

/// Represents the resolved targets for a shortcut at a time.
///
/// You can use the [`Gestures::shortcut_actions`] method to get a value of this.
#[derive(Debug, Clone)]
pub struct ShortcutActions {
    shortcut: Shortcut,

    focus: Option<WidgetId>,
    click: Option<(InteractionPath, ShortcutClick)>,
    commands: Vec<Command>,
}
impl ShortcutActions {
    fn new(
        vars: &Vars,
        events: &mut Events,
        gestures: &mut Gestures,
        focus: &mut Focus,
        windows: &mut Windows,
        shortcut: Shortcut,
    ) -> ShortcutActions {
        //    **First exclusively**:
        //
        //    * Primary [`click_shortcut`] targeting a widget that is enabled and focused.
        //    * Command scoped in a widget that is enabled and focused.
        //    * Contextual [`click_shortcut`] targeting a widget that is enabled and focused.
        //    * Primary [`click_shortcut`] targeting a widget that is enabled.
        //    * Command scoped in a widget that is enabled.
        //    * Contextual [`click_shortcut`] targeting a widget that is enabled.
        //    * [`focus_shortcut`] targeting a widget that is enabled.
        //    * The [`click_focused`] and [`context_click_focused`].
        //    * *Same as the above, but for disabled widgets*
        //
        //     **And then:**
        //
        //    a. All enabled commands targeting the focused window.
        //
        //    b. All enabled commands targeting the app.

        let focused = focus.focused();
        let focused = focused.get(vars);

        let mut primary_click_focused = None;
        let mut primary_click_not_focused = None;
        let mut primary_click_disabled_focused = None;
        let mut primary_click_disabled_not_focused = None;

        let mut context_click_focused = None;
        let mut context_click_not_focused = None;
        let mut context_click_disabled_focused = None;
        let mut context_click_disabled_not_focused = None;

        let mut cmd_focused_widget = None;
        let mut cmd_not_focused_widget = None;
        let mut cmd_window = vec![];
        let mut cmd_other = vec![];

        let mut focus_enabled = None;
        let mut focus_disabled = None;

        let mut cleanup = true;

        // primary click
        for (s, entry) in &gestures.primary_clicks {
            if shortcut == *s {
                if entry.handle.is_dropped() {
                    cleanup = true;
                    continue;
                }

                if let Some(p) = entry.resolve_path(windows) {
                    if focused.as_ref().map(|f| f.widget_id() == p.widget_id()).unwrap_or(false) {
                        if p.interactivity().is_enabled() {
                            primary_click_focused = Some(p);
                            break;
                        } else if primary_click_disabled_focused.is_none() {
                            primary_click_disabled_focused = Some(p);
                        }
                    } else if p.interactivity().is_enabled() {
                        if primary_click_not_focused.is_none() {
                            primary_click_not_focused = Some(p);
                        }
                    } else if primary_click_disabled_not_focused.is_none() {
                        primary_click_disabled_not_focused = Some(p);
                    }
                }
            }
        }

        // commands
        for cmd in events.commands() {
            if cmd.shortcut_matches(vars, shortcut) {
                match cmd.scope() {
                    CommandScope::Window(w) => {
                        if let Some(f) = focused {
                            if f.window_id() == w {
                                cmd_window.push(cmd);
                            }
                        }
                    }
                    CommandScope::Widget(id) => {
                        if primary_click_focused.is_none() && cmd_focused_widget.is_none() {
                            if focused.as_ref().map(|f| f.widget_id() == id).unwrap_or(false) {
                                cmd_focused_widget = Some(cmd);
                            } else if cmd_not_focused_widget.is_none() {
                                for tree in windows.widget_trees() {
                                    if let Some(info) = tree.get(id) {
                                        if info.interactivity().is_enabled() {
                                            cmd_not_focused_widget = Some(cmd);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    CommandScope::App => cmd_other.push(cmd),
                }
            }
        }

        // context click
        if primary_click_focused.is_none() && cmd_focused_widget.is_none() {
            for (s, entry) in &gestures.context_clicks {
                if shortcut == *s {
                    if entry.handle.is_dropped() {
                        cleanup = true;
                        continue;
                    }

                    if let Some(p) = entry.resolve_path(windows) {
                        if focused.as_ref().map(|f| f.widget_id() == p.widget_id()).unwrap_or(false) {
                            if p.interactivity().is_enabled() {
                                context_click_focused = Some(p);
                                break;
                            } else if context_click_disabled_focused.is_none() {
                                context_click_disabled_focused = Some(p);
                            }
                        } else if p.interactivity().is_enabled() {
                            if context_click_not_focused.is_none() {
                                context_click_not_focused = Some(p);
                            }
                        } else if context_click_disabled_not_focused.is_none() {
                            context_click_disabled_not_focused = Some(p);
                        }
                    }
                }
            }
        }

        // resolve click given the primary, context and command options.
        #[allow(clippy::manual_map)]
        let mut click = if let Some(p) = primary_click_focused {
            cmd_focused_widget = None;
            Some((p, ShortcutClick::Primary))
        } else if cmd_focused_widget.is_some() {
            None
        } else if let Some(p) = context_click_focused {
            Some((p, ShortcutClick::Context))
        } else if let Some(p) = primary_click_not_focused {
            cmd_not_focused_widget = None;
            Some((p, ShortcutClick::Primary))
        } else if cmd_not_focused_widget.is_some() {
            None
        } else if let Some(p) = context_click_not_focused {
            Some((p, ShortcutClick::Context))
        } else {
            None
        };

        // focus shortcut
        if click.is_none() {
            for (s, entry) in &gestures.focus {
                if shortcut == *s {
                    if entry.handle.is_dropped() {
                        cleanup = true;
                        continue;
                    }

                    if let Some(p) = entry.resolve_path(windows) {
                        if p.interactivity().is_enabled() {
                            focus_enabled = Some(p.widget_id());
                            break;
                        } else if focus_disabled.is_none() {
                            focus_disabled = Some(p.widget_id())
                        }
                    }
                }
            }
        }
        let focus = focus_enabled.or(focus_disabled);

        // click focused if no click or focus request matched.
        if click.is_none() && focus.is_none() {
            if let Some(p) = focused {
                click = if gestures.click_focused.contains(shortcut) {
                    Some((p.clone(), ShortcutClick::Primary))
                } else if gestures.context_click_focused.contains(shortcut) {
                    Some((p.clone(), ShortcutClick::Context))
                } else {
                    None
                };
            }
        }

        let commands = cmd_focused_widget
            .or(cmd_not_focused_widget)
            .into_iter()
            .chain(cmd_window)
            .chain(cmd_other)
            .collect();

        if cleanup {
            gestures.cleanup();
        }

        Self {
            shortcut,
            focus,
            click,
            commands,
        }
    }

    /// The shortcut.
    pub fn shortcut(&self) -> Shortcut {
        self.shortcut
    }

    /// Focus target.
    ///
    /// If `click` is some, this is a direct focus request to it, or if the first command is scoped on a widget this
    /// is a direct focus request on the scope, or if this is some it is a direct or related request to the focus shortcut target.
    pub fn focus(&self) -> Option<FocusTarget> {
        if let Some((p, _)) = &self.click {
            return Some(FocusTarget::Direct(p.widget_id()));
        } else if let Some(c) = self.commands.first() {
            if let CommandScope::Widget(w) = c.scope() {
                return Some(FocusTarget::Direct(w));
            }
        }
        self.focus.map(FocusTarget::DirectOrRelated)
    }

    /// Click target and kind.
    pub fn click(&self) -> Option<(&InteractionPath, ShortcutClick)> {
        self.click.as_ref().map(|(p, k)| (p, *k))
    }

    /// Commands.
    ///
    /// Only the first command may be scoped in a widget, others are scoped on the focused window or app.
    pub fn commands(&self) -> &[Command] {
        &self.commands
    }

    /// If any action was found for the shortcut.
    pub fn has_actions(&self) -> bool {
        self.click.is_some() || self.focus.is_some() || !self.commands.is_empty()
    }

    /// Send all events and focus request.
    fn run(
        &self,
        events: &mut Events,
        focus: &mut Focus,
        timestamp: Instant,
        propagation: &EventPropagationHandle,
        device_id: Option<DeviceId>,
        is_repeat: bool,
    ) {
        if let Some(target) = self.focus() {
            focus.focus(FocusRequest::new(target, true));
        }

        if let Some((target, kind)) = &self.click {
            let args = ClickArgs::new(
                timestamp,
                propagation.clone(),
                target.window_id(),
                device_id,
                ClickArgsSource::Shortcut {
                    shortcut: self.shortcut,
                    is_repeat,
                    kind: *kind,
                },
                NonZeroU32::new(1).unwrap(),
                self.shortcut.modifiers_state(),
                target.clone(),
            );
            CLICK_EVENT.notify(events, args);
        }
        for command in &self.commands {
            command.notify_linked(events, propagation.clone(), None);
        }
    }
}

/// Represents shortcuts claim in [`click_shortcut`] or [`focus_shortcut`].
///
/// Drop all clones of this handle to stop the animation, or call [`perm`] to drop the handle
/// but keep the animation alive until it is stopped from the inside.
///
/// [`perm`]: ShortcutsHandle::perm
/// [`click_shortcut`]: Gestures::click_shortcut
/// [`focus_shortcut`]: Gestures::focus_shortcut
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
#[repr(transparent)]
#[must_use = "the shortcuts claim is removed if the handle is dropped"]
pub struct ShortcutsHandle(Handle<()>);
impl ShortcutsHandle {
    pub(super) fn new() -> (HandleOwner<()>, Self) {
        let (owner, handle) = Handle::new(());
        (owner, ShortcutsHandle(handle))
    }

    /// Create dummy handle that is always in the *released* state.
    ///
    /// Note that `Option<ShortcutsHandle>` takes up the same space as `ShortcutsHandle` and avoids an allocation.
    pub fn dummy() -> Self {
        assert_non_null!(ShortcutsHandle);
        ShortcutsHandle(Handle::dummy(()))
    }

    /// Drop the handle but does **not** release.
    ///
    /// The claim stays registered for the duration of the app or until another handle calls [`release`](Self::release).
    /// Note that shortcut claims only work if the target widget is found and is not [`BLOCKED`].
    ///
    /// [`BLOCKED`]: crate::widget_info::Interactivity::BLOCKED
    pub fn perm(self) {
        self.0.perm();
    }

    /// If another handle has called [`perm`](Self::perm).
    ///
    /// If `true` the claim will stay active until the app exits, unless [`release`](Self::release) is called.
    pub fn is_permanent(&self) -> bool {
        self.0.is_permanent()
    }

    /// Drops the handle and releases the claim
    pub fn release(self) {
        self.0.force_drop();
    }

    /// If another handle has called [`release`](Self::release).
    ///
    /// The claim is already dropped or will be dropped in the next app update, this is irreversible.
    pub fn is_released(&self) -> bool {
        self.0.is_dropped()
    }

    /// Create a weak handle.
    pub fn downgrade(&self) -> WeakShortcutsHandle {
        WeakShortcutsHandle(self.0.downgrade())
    }
}

/// Weak [`ShortcutsHandle`].
#[derive(Clone, PartialEq, Eq, Hash, Default, Debug)]
pub struct WeakShortcutsHandle(pub(super) WeakHandle<()>);
impl WeakShortcutsHandle {
    /// New weak handle that does not upgrade.
    pub fn new() -> Self {
        Self(WeakHandle::new())
    }

    /// Get the shortcuts handle if it is still installed.
    pub fn upgrade(&self) -> Option<ShortcutsHandle> {
        self.0.upgrade().map(ShortcutsHandle)
    }
}

impl std::str::FromStr for ModifierGesture {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.trim() {
            "Ctrl" => Ok(ModifierGesture::Ctrl),
            "Shift" => Ok(ModifierGesture::Shift),
            "Alt" => Ok(ModifierGesture::Alt),
            "Logo" => Ok(ModifierGesture::Logo),
            s => Err(ParseError::new(format!("`{s}` is not a modifier"))),
        }
    }
}

impl std::str::FromStr for KeyGesture {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut modifiers = ModifiersState::empty();
        let mut parts = s.split('+');

        while let Some(part) = parts.next() {
            if let Ok(mod_) = part.parse::<ModifierGesture>() {
                match mod_ {
                    ModifierGesture::Logo => modifiers |= ModifiersState::LOGO,
                    ModifierGesture::Ctrl => modifiers |= ModifiersState::CTRL,
                    ModifierGesture::Shift => modifiers |= ModifiersState::SHIFT,
                    ModifierGesture::Alt => modifiers |= ModifiersState::ALT,
                }
            } else if let Ok(key) = part.parse::<GestureKey>() {
                if let Some(extra) = parts.next() {
                    return Err(ParseError::new(format!("`{s}` is not a key gesture, unexpected `+{extra}`")));
                }

                return Ok(KeyGesture { modifiers, key });
            } else {
                return Err(ParseError::new(format!("`{s}` is not a key gesture, unexpected `{part}`")));
            }
        }

        Err(ParseError::new(format!("`{s}` is not a key gesture, missing key")))
    }
}

impl std::str::FromStr for KeyChord {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split(',');

        let starter = if let Some(starter) = parts.next() {
            starter.parse()?
        } else {
            return Err(ParseError::new("`` is not a key chord, empty"));
        };

        let complement = if let Some(complement) = parts.next() {
            complement.parse()?
        } else {
            return Err(ParseError::new(format!("`{s}` is not a key chord, expected `, <complement>`")));
        };

        if let Some(extra) = parts.next() {
            return Err(ParseError::new(format!("`{s}` is not a key chord, unexpected `,{extra}`")));
        }

        Ok(KeyChord { starter, complement })
    }
}

impl std::str::FromStr for Shortcut {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.contains(',') {
            s.parse().map(Shortcut::Chord)
        } else if s.contains('+') {
            s.parse().map(Shortcut::Gesture)
        } else {
            s.parse()
                .map(Shortcut::Modifier)
                .map_err(|_| ParseError::new(format!("`{s}` is not a shortcut")))
        }
    }
}

macro_rules! gesture_key_name {
    ($key:ident = $name:expr) => {
        $name
    };
    ($key:ident) => {
        stringify!($key)
    };
}

macro_rules! gesture_keys {
    ($($(#[$docs:meta])* $key:ident $(= $name:expr)?),+ $(,)?) => {
        /// The set of keys that can be used in a [`KeyGesture`].
        #[derive(Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(u32)]
        #[allow(missing_docs)] // they are mostly self-explanatory.
        pub enum GestureKey {
            $(
                $(#[$docs])*
                $key
            ),+
        }
        impl fmt::Debug for GestureKey {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                if f.alternate() {
                    write!(f, "GestureKey::")?;
                }
                match self {
                    $(
                        GestureKey::$key => write!(f, "{}", stringify!($key)),
                    )+
                }
            }
        }
        impl TryFrom<Key> for GestureKey {
            type Error = Key;

            fn try_from(key: Key) -> Result<Self, Key> {
                match key {
                    $(Key::$key => Ok(GestureKey::$key),)+
                    _ => Err(key)
                }
            }
        }
        impl From<GestureKey> for Key {
            fn from(key: GestureKey) -> Key {
                match key {
                    $(GestureKey::$key => Key::$key,)+
                }
            }
        }
        impl Display for GestureKey {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    $(GestureKey::$key => gesture_key_name!($key $(=$name)?).fmt(f),)+
                }
            }
        }
        impl std::str::FromStr for GestureKey {
            type Err = ParseError;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s.trim() {
                    $(stringify!($key) $(| $name)? => Ok(Self::$key),)+
                    s => Err(ParseError::new(format!("`{s}` is not a gesture key")))
                }
            }
        }
    };
}

gesture_keys! {
    /// The '1' key over the letters.
    Key1 = "1",
    /// The '2' key over the letters.
    Key2 = "2",
    /// The '3' key over the letters.
    Key3 = "3",
    /// The '4' key over the letters.
    Key4 = "4",
    /// The '5' key over the letters.
    Key5 = "5",
    /// The '6' key over the letters.
    Key6 = "6",
    /// The '7' key over the letters.
    Key7 = "7",
    /// The '8' key over the letters.
    Key8 = "8",
    /// The '9' key over the letters.
    Key9 = "9",
    /// The '0' key over the 'O' and 'P' keys.
    Key0 = "0",
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    /// The Escape key, next to F1.
    Escape = "Esc",
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    Pause,
    Insert,
    Home,
    Delete,
    End,
    PageDown = "Page Down",
    PageUp = "Page Up",
    Left,
    Up,
    Right,
    Down,
    /// The Backspace key, right over Enter.
    Backspace,
    /// The Return key.
    Enter,
    /// The space bar.
    Space,
    Plus = "+",
    Asterisk = "*",
    Apostrophe = "'",
    Backslash = "\\",
    Comma = ",",
    Slash = "/",
    Equals = "=",
    Minus = "-",
    Period = ".",
    Numpad1 = "Numpad 1",
    Numpad2 = "Numpad 2",
    Numpad3 = "Numpad 3",
    Numpad4 = "Numpad 4",
    Numpad5 = "Numpad 5",
    Numpad6 = "Numpad 6",
    Numpad7 = "Numpad 7",
    Numpad8 = "Numpad 8",
    Numpad9 = "Numpad 9",
    Numpad0 = "Numpad 0",
    NumpadComma = "Numpad ,",
    NumpadAdd = "Numpad +",
    NumpadSubtract = "Numpad -",
    NumpadMultiply = "Numpad *",
    NumpadDivide = "Numpad /",
    NumpadEnter = "Numpad Enter",
    Tab,
    Apps,
}

/// Shortcut, gesture parsing error.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseError {
    /// Error message, usually in the pattern "`{invalid-input}` is not a {shortcut/modifier}".
    pub error: String,
}
impl ParseError {
    #[allow(missing_docs)]
    pub fn new(error: impl ToString) -> Self {
        ParseError { error: error.to_string() }
    }
}
impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.error.fmt(f)
    }
}
impl std::error::Error for ParseError {}

/// Extension trait that adds gesture simulation methods to [`HeadlessApp`].
pub trait HeadlessAppGestureExt {
    /// Does key presses to mimic the shortcut and updates.
    fn press_shortcut(&mut self, window_id: WindowId, shortcut: impl Into<Shortcut>);
}
impl HeadlessAppGestureExt for HeadlessApp {
    fn press_shortcut(&mut self, window_id: WindowId, shortcut: impl Into<Shortcut>) {
        let shortcut = shortcut.into();
        match shortcut {
            Shortcut::Modifier(m) => {
                self.press_key(window_id, m.left_key());
            }
            Shortcut::Gesture(g) => {
                self.press_modified_key(window_id, g.modifiers, g.key.into());
            }
            Shortcut::Chord(c) => {
                self.press_shortcut(window_id, c.starter);
                self.press_shortcut(window_id, c.complement);
            }
        }
    }
}

/// Adds the [`shortcut`](Self::shortcut) metadata.
///
/// If a command has a shortcut the [`GestureManager`] will invoke the command when the shortcut is pressed
/// the command is enabled, if the command target is a widget it will be focused as well. See the [`Gestures`]
/// service documentation for details on how shortcuts are resolved.
pub trait CommandShortcutExt {
    /// Gets a read-write variable that is zero-or-more shortcuts that invoke the command.
    fn shortcut(self) -> CommandMetaVar<Shortcuts>;

    /// Sets the initial shortcuts.
    fn init_shortcut(self, shortcut: impl Into<Shortcuts>) -> Self;

    /// Returns `true` if the command has handlers, enabled or disabled, and the shortcut if one of the command shortcuts.
    ///
    /// [`App`]: crate::command::CommandScope::App
    /// [`Custom`]: crate::command::CommandScope::Custom
    fn shortcut_matches<Vr: WithVarsRead>(self, vars: &Vr, shortcut: Shortcut) -> bool;
}
impl CommandShortcutExt for Command {
    fn shortcut(self) -> CommandMetaVar<Shortcuts> {
        self.with_meta(|m| m.get_var_or_default(&COMMAND_SHORTCUT_ID))
    }

    fn init_shortcut(self, shortcut: impl Into<Shortcuts>) -> Self {
        self.with_meta(|m| m.init_var(&COMMAND_SHORTCUT_ID, shortcut.into()));
        self
    }

    fn shortcut_matches<Vr: WithVarsRead>(self, vars: &Vr, shortcut: Shortcut) -> bool {
        vars.with_vars_read(|vars| self.has_handlers().copy(vars) && self.shortcut().get(vars).contains(shortcut))
    }
}

static COMMAND_SHORTCUT_ID: StaticCommandMetaVarId<Shortcuts> = StaticCommandMetaVarId::new_unique();
