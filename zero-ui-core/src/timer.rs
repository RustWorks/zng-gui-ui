//! App thread timers, deadlines and timeouts.
//!
//! The primary `struct` of this module is [`Timers`]. You can use it to
//! create UI bound timers that run using only the main thread and can awake the app event loop
//! to notify updates.
use std::{
    cell::Cell,
    mem,
    sync::{
        atomic::{AtomicBool, AtomicUsize, Ordering},
        Mutex,
    },
    time::{Duration, Instant},
};

use retain_mut::RetainMut;

use crate::{
    context::AppContext,
    crate_util::{Handle, HandleOwner},
    handler::{self, AppHandler, AppHandlerArgs, AppWeakHandle},
    var::{var, RcVar, ReadOnlyVar, Var, Vars},
};

struct DeadlineHandlerEntry {
    handle: HandleOwner<DeadlineState>,
    #[allow(clippy::type_complexity)]
    handler: Option<Box<dyn FnOnce(&mut AppContext, &dyn AppWeakHandle)>>,
    pending: bool,
}

struct TimerHandlerEntry {
    handle: HandleOwner<TimerState>,
    handler: Box<dyn FnMut(&mut AppContext, &mut Timer)>,
    pending: bool,
}

/// App thread timers, deadlines and timeouts.
///
/// An instance of this `struct` is available in the [`AppContext`] and derived contexts. You can use it to
/// create UI bound timers, these timers run using only the main thread and can awake the app event loop
/// to notify updates.
///
/// Timer updates can be observed using variables that update when the timer elapses, or you can register
/// handlers to be called directly when the time elapses. Timers can be *one-time*, updating only once when
/// a [`deadline`](Timers::deadline) is reached or a [`timeout`](Timers::timeout) elapses; or they can update every time on a
/// set [`interval`](Timers::interval).
///
/// # Async
///
/// Timers generated by this `struct` are not [`Send`] and are bound to the UI thread, however you can `.await` then in UI bound async
/// code, like in async event handlers, by using the [variable](Var) async update methods. You can also register async handlers for the
/// callback timers using the [`async_app_hn!`](crate::handler::async_app_hn!) or [`async_app_hn_once!`](crate::async_app_hn_once!) 
/// macros.
///
/// To create timers that work in any thread and independent from the running app use the [`task`](crate::task) module timers functions.
pub struct Timers {
    deadlines: Vec<RcVar<Deadline>>,
    timers: Vec<RcVar<Timer>>,
    deadline_handlers: Vec<DeadlineHandlerEntry>,
    timer_handlers: Vec<TimerHandlerEntry>,
}
impl Timers {
    pub(crate) fn new() -> Self {
        Timers {
            deadlines: vec![],
            timers: vec![],
            deadline_handlers: vec![],
            timer_handlers: vec![],
        }
    }

    /// Returns a [`DeadlineVar`] that will update once when the `deadline` is reached.
    ///
    /// If the `deadline` is in the past the variable will still update once in the next app update. 
    /// Drop all clones of the variable to cancel the timer.
    ///
    /// ```
    /// # use zero_ui_core::timer::*;
    /// # use zero_ui_core::handler::*;
    /// # use zero_ui_core::units::*;
    /// # use zero_ui_core::var::*;
    /// # use zero_ui_core::context::WidgetContext;
    /// # use std::time::Instant;
    /// # fn foo(ctx: &mut WidgetContext) {
    /// let deadline = ctx.timers.deadline(Instant::now() + 20.secs());
    ///
    /// # let
    /// text = deadline.map(|d| if d.elapsed { "20 seconds have passed" } else { "..." });
    /// # }
    /// ```
    ///
    /// In the example above the deadline variable starts with [`elapsed`](Deadline::elapsed) set to `false`,
    /// 20 seconds later the variable will update with [`elapsed`](Deadline::elapsed) set to `true`. The variable
    /// is read-only and will only update once.
    #[inline]
    #[must_use]
    pub fn deadline(&mut self, deadline: Instant) -> DeadlineVar {
        let timer = var(Deadline { deadline, elapsed: false });
        self.deadlines.push(timer.clone());
        timer.into_read_only()
    }

    /// Returns a [`DeadlineVar`] that will update once when the `timeout` has elapsed.
    ///
    /// This method just calculates the [`deadline`](Self::deadline), from the time this method is called plus `timeout`.
    #[inline]
    #[must_use]
    pub fn timeout(&mut self, timeout: Duration) -> DeadlineVar {
        self.deadline(Instant::now() + timeout)
    }

    /// Returns a [`TimerVar`] that will update every time the `interval` elapses.
    ///
    /// The timer can be controlled using methods in the variable value.
    ///
    /// ```
    /// # use zero_ui_core::timer::*;
    /// # use zero_ui_core::handler::*;
    /// # use zero_ui_core::units::*;
    /// # use zero_ui_core::var::*;
    /// # use zero_ui_core::text::*;
    /// # use zero_ui_core::context::WidgetContext;
    /// # use std::time::Instant;
    /// # fn foo(ctx: &mut WidgetContext) {
    /// let timer = ctx.timers.interval(1.secs());
    ///
    /// # let
    /// text = timer.map(|t| match t.count() {
    ///     0 => formatx!(""),
    ///     1 => formatx!("1 second elapsed"),
    ///     c => formatx!("{} seconds elapsed", c)
    /// });
    /// # }
    /// ```
    ///
    /// In the example above the timer variable will update every second, the variable keeps a [`count`](Timer::count)
    /// of times the time elapsed, that is incremented every update. The variable is read-only but the value can
    /// be used to control the timer to some extent, see [`TimerVar`] for details.
    #[inline]
    #[must_use]
    pub fn interval(&mut self, interval: Duration) -> TimerVar {
        let timer = var(Timer {
            request: Cell::new(TimerRequest::None),
            interval,
            deadline: Cell::new(Instant::now() + interval),
            count: Cell::new(0),
        });
        self.timers.push(timer.clone());
        timer.into_read_only()
    }

    /// Register a `handler` that will be called once when the `deadline` is reached.
    ///
    /// If the `deadline` is in the past the `handler` will be called in the next app update.
    ///
    /// ```
    /// # use zero_ui_core::timer::*;
    /// # use zero_ui_core::handler::*;
    /// # use zero_ui_core::units::*;
    /// # use zero_ui_core::context::AppContext;
    /// # use std::time::Instant;
    /// # fn foo(ctx: &mut AppContext) {
    /// let handle = ctx.timers.on_deadline(Instant::now() + 20.secs(), app_hn_once!(|ctx, _| {
    ///     println!("20 seconds have passed");
    /// }));
    /// # }
    /// ```
    ///
    /// # Handler
    ///
    /// The `handler` can be any of the *once* [`AppHandler`] implementers. You can use the macros 
    /// [`app_hn_once!`](crate::handler::app_hn_once!) or [`async_hn_once!`](crate::handler::async_app_hn_once!) 
    /// to declare a handler closure.
    ///
    /// Async handlers execute up to the first `.await` immediately when the `deadline` is reached, subsequent awakes
    /// are scheduled like an async *preview* event handler.
    ///
    /// # Handle
    ///
    /// Returns a [`DeadlineHandle`] that can be used to cancel the timer, either by dropping the handle or by
    /// calling [`cancel`](DeadlineHandle::cancel). You can also call [`permanent`](DeadlineHandle::permanent)
    /// to drop the handle without cancelling.
    pub fn on_deadline<H>(&mut self, deadline: Instant, mut handler: H) -> DeadlineHandle
    where
        H: AppHandler<DeadlineArgs> + handler::marker::OnceHn,
    {
        let (handle_owner, handle) = DeadlineHandle::new(deadline);
        self.deadline_handlers.push(DeadlineHandlerEntry {
            handle: handle_owner,
            handler: Some(Box::new(move |ctx, handle| {
                handler.event(
                    ctx,
                    &DeadlineArgs {
                        timestamp: Instant::now(),
                        deadline,
                    },
                    &AppHandlerArgs { handle, is_preview: true },
                )
            })),
            pending: false,
        });
        handle
    }

    /// Register a `handler` that will be called once when `timeout` elapses.
    ///
    /// This method just calculates the deadline for [`on_deadline`](Self::on_deadline). The deadline is calculated
    /// from the time this method is called plus `timeout`.
    pub fn on_timeout<H>(&mut self, timeout: Duration, handler: H) -> DeadlineHandle
    where
        H: AppHandler<DeadlineArgs> + handler::marker::OnceHn,
    {
        self.on_deadline(Instant::now() + timeout, handler)
    }

    /// Register a `handler` that will be called every time the `interval` elapses.
    pub fn on_interval<F>(&mut self, interval: Duration, handler: F) -> TimerHandle
    where
        F: FnMut(&mut AppContext, &mut Timer) + 'static,
    {
        let (owner, handle) = TimerHandle::new(interval);

        self.timer_handlers.push(TimerHandlerEntry {
            handle: owner,
            handler: Box::new(handler),
            pending: false,
        });
        handle
    }

    /// Update timers, returns new app wake time.
    pub(crate) fn apply_updates(&mut self, vars: &Vars) -> Option<Instant> {
        let now = Instant::now();

        let mut min_next_some = false;
        let mut min_next = now + Duration::from_secs(60 * 60 * 60);

        self.deadlines.retain(|t| {
            let mut retain = t.strong_count() > 1;
            let deadline = t.get(vars).deadline;
            if retain && deadline <= now {
                t.modify(vars, |t| t.elapsed = true);
                retain = false;
            } else {
                min_next_some = true;
                min_next = min_next.min(deadline);
            }
            retain
        });

        self.timers.retain(|t| {
            let info = t.get(vars);
            let retain = t.strong_count() > 1 && !info.is_stopped();
            if retain && info.is_enabled() {
                if info.deadline.get() <= now {
                    info.deadline.set(now + info.interval());
                    info.count.set(info.count.get().wrapping_add(1));
                    t.touch(vars);
                }
                min_next_some = true;
                min_next = min_next.min(info.deadline.get());
            } else {
                info.stop();
            }
            retain
        });

        self.deadline_handlers.retain_mut(|e| {
            let retain = !e.handle.is_dropped();
            if retain {
                let deadline = e.handle.data().deadline;
                e.pending = deadline <= now;
                if !e.pending {
                    min_next_some = true;
                    min_next = min_next.min(deadline);
                }
            }
            retain
        });

        self.timer_handlers.retain_mut(|e| {
            let retain = !e.handle.is_dropped();
            if retain {
                let state = e.handle.data();
                let mut deadline = state.deadline.lock().unwrap();
                e.pending = *deadline <= now;
                if e.pending {
                    *deadline = now + *state.interval.lock().unwrap();

                    if !state.enabled.load(Ordering::Relaxed) {
                        e.pending = false;
                        // this is wrapping_add
                        state.count.fetch_add(1, Ordering::Relaxed);
                    }
                }
                min_next_some = true;
                min_next = min_next.min(*deadline);
            }
            retain
        });

        if min_next_some {
            Some(min_next)
        } else {
            None
        }
    }

    pub(crate) fn notify(ctx: &mut AppContext) {
        let mut handlers = mem::take(&mut ctx.timers.deadline_handlers);
        handlers.retain_mut(|h| {
            if h.pending {
                h.handler.take().unwrap()(ctx, &h.handle.weak_handle());
                h.handle.data().executed.store(true, Ordering::Relaxed);
            }
            !h.pending
        });
        handlers.extend(ctx.timers.deadline_handlers.drain(..));
        ctx.timers.deadline_handlers = handlers;

        let mut handlers = mem::take(&mut ctx.timers.timer_handlers);
        handlers.retain_mut(|h| {
            if h.pending {
                let data = h.handle.data();
                let mut timer = Timer {
                    request: Cell::new(TimerRequest::None),
                    interval: *data.interval.lock().unwrap(),
                    deadline: Cell::new(*data.deadline.lock().unwrap()),
                    count: Cell::new(data.count.load(Ordering::Relaxed)),
                };
                (h.handler)(ctx, &mut timer);
                h.pending = false;

                data.count.store(timer.count(), Ordering::Relaxed);
                *data.interval.lock().unwrap() = timer.interval;

                match timer.request.get() {
                    TimerRequest::Disable => data.enabled.store(false, Ordering::Relaxed),
                    TimerRequest::Stop => return false,
                    TimerRequest::None => {}
                }
            }
            !h.handle.is_dropped()
        });
        handlers.extend(ctx.timers.timer_handlers.drain(..));
        ctx.timers.timer_handlers = handlers;
    }
}

/// Represents the state of a [`DeadlineVar`].
#[derive(Debug, Clone)]
pub struct Deadline {
    /// Deadline for the timer to elapse, this value does not change.
    pub deadline: Instant,
    /// If the timer has elapsed, the initial value is `false`, once the timer elapses the value is updated to `true`.
    pub elapsed: bool,
}

/// A [`deadline`](Timers::deadline) or [`timeout`](Timers::timeout) timer.
///
/// This is a read-only variable of type [`Deadline`], it will update once when the timer elapses.
///
/// Drop all clones of this variable to cancel the timer.
///
/// ```
/// # use zero_ui_core::timer::*;
/// # use zero_ui_core::handler::*;
/// # use zero_ui_core::units::*;
/// # use zero_ui_core::var::*;
/// # use zero_ui_core::context::WidgetContext;
/// # use std::time::Instant;
/// # fn foo(ctx: &mut WidgetContext) {
/// let deadline: DeadlineVar = ctx.timers.deadline(Instant::now() + 20.secs());
///
/// # let
/// text = deadline.map(|d| if d.elapsed { "20 seconds have passed" } else { "..." });
/// # }
/// ```
///
/// In the example above the variable is mapped to a text, there are many other things you can do with variables,
/// including `.await` for the update in UI bound async tasks. See [`Var`] for details. 
pub type DeadlineVar = ReadOnlyVar<Deadline, RcVar<Deadline>>;

/// Represents a [`on_deadline`](Timers::on_deadline) or [`on_timeout`](Timers::on_timeout) handler.
///
/// Drop all clones of this handle to cancel the timer, or call [`permanent`](Self::permanent) to drop the handle
/// without cancelling the timer.
#[derive(Clone)]
#[must_use = "the timer is canceled if the handler is dropped"]
pub struct DeadlineHandle(Handle<DeadlineState>);
struct DeadlineState {
    deadline: Instant,
    executed: AtomicBool,
}
impl DeadlineHandle {
    /// Create a handle to nothing, the handle always in the *canceled* state.
    pub fn dummy() -> DeadlineHandle {
        DeadlineHandle(Handle::dummy(DeadlineState {
            deadline: Instant::now(),
            executed: AtomicBool::new(false),
        }))
    }

    fn new(deadline: Instant) -> (HandleOwner<DeadlineState>, Self) {
        let (owner, handle) = Handle::new(DeadlineState {
            deadline,
            executed: AtomicBool::new(false),
        });
        (owner, DeadlineHandle(handle))
    }

    /// Drops the handle but does **not** drop the handler closure.
    ///
    /// The handler closure will be dropped after it is executed or when the app shutdown.
    #[inline]
    pub fn permanent(self) {
        self.0.permanent();
    }

    /// If [`permanent`](Self::permanent) was called in another handle.
    /// If `true` the closure will be dropped when it executes, when the app shutdown or if [`cancel`](Self::cancel) is called.
    #[inline]
    pub fn is_permanent(&self) -> bool {
        self.0.is_permanent()
    }

    /// Drops the handle and forces the handler to drop.
    ///
    /// If the deadline has not been reached the handler will not be called, and will drop in the next app update.
    #[inline]
    pub fn cancel(self) {
        self.0.force_drop();
    }

    /// The timeout deadline.
    ///
    /// The handler is called once when this deadline is reached.
    #[inline]
    pub fn deadline(&self) -> Instant {
        self.0.data().deadline
    }

    /// If the handler has executed. The handler executes once when the deadline is reached.
    #[inline]
    pub fn has_executed(&self) -> bool {
        self.0.data().executed.load(Ordering::Relaxed)
    }

    /// If the timeout handler will never execute. Returns `true` if [`cancel`](Self::cancel) was called
    /// before the handler could execute.
    #[inline]
    pub fn is_canceled(&self) -> bool {
        !self.has_executed() && self.0.is_dropped()
    }
}

/// Arguments for the handler of [`on_deadline`](Timers::on_deadline) or [`on_timeout`](Timers::on_timeout).
#[derive(Clone, Debug)]
pub struct DeadlineArgs {
    /// When the handler was called.
    pub timestamp: Instant,
    /// Timer deadline, is less-or-equal to the [`timestamp`](Self::timestamp).
    pub deadline: Instant,
}

/// Represents a [`on_interval`](Timers::on_interval) handler.
///
/// Drop all clones of this handler to stop the timer, or call [`permanent`](Self::permanent) to drop the handler
/// without cancelling the timer.
#[derive(Clone)]
#[must_use = "the timer is stopped if the handler is dropped"]
pub struct TimerHandle(Handle<TimerState>);
struct TimerState {
    enabled: AtomicBool,
    interval: Mutex<Duration>,
    deadline: Mutex<Instant>,
    count: AtomicUsize,
}
impl TimerHandle {
    fn new(interval: Duration) -> (HandleOwner<TimerState>, TimerHandle) {
        let (owner, handle) = Handle::new(TimerState {
            enabled: AtomicBool::new(true),
            interval: Mutex::new(interval),
            deadline: Mutex::new(Instant::now() + interval),
            count: AtomicUsize::new(0),
        });
        (owner, TimerHandle(handle))
    }

    /// Create a handle to nothing, the handle is always in the *stopped* state.
    pub fn dummy() -> TimerHandle {
        TimerHandle(Handle::dummy(TimerState {
            enabled: AtomicBool::new(false),
            interval: Mutex::new(Duration::MAX),
            deadline: Mutex::new(Instant::now()),
            count: AtomicUsize::new(0),
        }))
    }

    /// Drops the handle but does **not** drop the handler closure.
    ///
    /// The handler closure will be dropped when the app shutdown or if it is stopped from the inside or using another handle.
    #[inline]
    pub fn permanent(self) {
        self.0.permanent();
    }

    /// If [`permanent`](Self::permanent) was called in another handle.
    /// If `true` the closure will keep being called until the app shutdown or the timer is stopped from the inside or using
    /// another handle.
    #[inline]
    pub fn is_permanent(&self) -> bool {
        self.0.is_permanent()
    }

    /// Drops the handle and forces the handler to drop.
    ///
    /// The handler will no longer be called and will drop in the next app update.
    #[inline]
    pub fn stop(self) {
        self.0.force_drop();
    }

    /// If the timer was stopped. The timer can be stopped from the inside, from another handle calling [`stop`](Self::stop)
    /// or from the app shutting down.
    #[inline]
    pub fn is_stopped(&self) -> bool {
        self.0.is_dropped()
    }

    /// The interval this timer operates in.
    #[inline]
    pub fn interval(&self) -> Duration {
        *self.0.data().interval.lock().unwrap()
    }

    /// The next deadline.
    ///
    /// The handler will be called when this deadline is reached and the deadline is then changed to the next deadline.
    #[inline]
    pub fn deadline(&self) -> Instant {
        *self.0.data().deadline.lock().unwrap()
    }

    /// If the handler is called when the timer elapses.
    #[inline]
    pub fn enabled(&self) -> bool {
        self.0.data().enabled.load(Ordering::Relaxed)
    }

    /// Disable or re-enable the timer. Disabled timers don't can call their handler and don't increase the [`count`](Self::count).
    #[inline]
    pub fn set_enabled(&self, enabled: bool) {
        self.0.data().enabled.store(enabled, Ordering::Relaxed);
    }

    /// Count incremented by one every time the timer elapses and it is [`enabled`](Self::count).
    #[inline]
    pub fn count(&self) -> usize {
        self.0.data().count.load(Ordering::Relaxed)
    }

    /// Resets the [`count`](Self::count).
    #[inline]
    pub fn set_count(&self, count: usize) {
        self.0.data().count.store(count, Ordering::Relaxed)
    }
}

/// An [`interval`](Timers::interval) timer.
///
/// This is a variable of type [`Timer`], it will update every time the timer elapses.
///
/// Drop all clones of this variable to stop the timer, you can also control the timer
/// with methods in the [`Timer`] value even though the variable is read-only.
///
/// ```
/// # use zero_ui_core::timer::*;
/// # use zero_ui_core::handler::*;
/// # use zero_ui_core::units::*;
/// # use zero_ui_core::var::*;
/// # use zero_ui_core::text::*;
/// # use zero_ui_core::context::WidgetContext;
/// # use std::time::Instant;
/// # fn foo(ctx: &mut WidgetContext) {
/// let timer: TimerVar = ctx.timers.interval(1.secs());
///
/// # let
/// text = timer.map(|d| match 20 - d.count() {
///     0 => {
///         d.stop();
///         formatx!("Done!")
///     },
///     1 => formatx!("1 second left"),
///     s => formatx!("{} seconds left", s)
/// });
/// # }
/// ```
///
/// In the example above the variable updates every second and stops after 20 seconds have elapsed. The variable
/// is mapped to a text and controls the timer from inside the mapping closure. See [`Var`] for other things you
/// can do with variables, including `.await` for updates. Also see [`Timer`] for more timer control methods.
pub type TimerVar = ReadOnlyVar<Timer, RcVar<Timer>>;

/// Represents a timer state in a [`TimerVar`] or interval handler.
#[derive(Debug, Clone)]
pub struct Timer {
    request: Cell<TimerRequest>,
    interval: Duration,
    deadline: Cell<Instant>,
    count: Cell<usize>,
}
#[derive(Debug, Clone, Copy)]
enum TimerRequest {
    None,
    Disable,
    Stop,
}
impl Timer {
    /// Disable the timer. Disabled timers don't can call their handler and don't increase the [`count`](Self::count).
    ///
    /// The timer can only be reenabled using an external handle. This can only be called in [`on_interval`](Timers::on_interval)
    /// handlers, it is not possible to disable a [`TimerVar`], only [`stop`](Self::stop) it.
    #[inline]
    pub fn disable(&mut self) {
        if !self.is_stopped() {
            self.request.set(TimerRequest::Disable);
        }
    }

    fn is_enabled(&self) -> bool {
        matches!(self.request.get(), TimerRequest::None)
    }

    /// Stop the timer. It will be dropped before the next elapse.
    #[inline]
    pub fn stop(&self) {
        self.request.set(TimerRequest::Stop);
    }

    /// If the timer is stopped.
    #[inline]
    pub fn is_stopped(&self) -> bool {
        matches!(self.request.get(), TimerRequest::Stop)
    }

    /// Count incremented by one every time the timer elapses.
    #[inline]
    pub fn count(&self) -> usize {
        self.count.get()
    }

    /// Resets the [`count`](Self::count). This can only be called in [`on_interval`](Timers::on_interval) handlers, it is not
    /// possible to change the count of a [`TimerVar`].
    #[inline]
    pub fn set_count(&mut self, count: usize) {
        self.count.set(count);
    }

    /// Gets the timer interval. The timer updates every time on this duration.
    #[inline]
    pub fn interval(&self) -> Duration {
        self.interval
    }

    /// Change the timer interval. This can only be called in for [`on_interval`](Timers::on_interval) handlers, it is not
    /// possible to change the interval of a [`TimerVar`].
    #[inline]
    pub fn set_interval(&mut self, new_interval: Duration) {
        self.interval = new_interval;
    }
}
