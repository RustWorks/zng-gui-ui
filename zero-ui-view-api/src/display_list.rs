use std::{cell::Cell, mem};

use linear_map::LinearMap;
use serde::{Deserialize, Serialize};
use webrender_api::{self as wr, PipelineId};

use crate::{units::*, FrameId};

/// Represents a builder for display items that will be rendered in the view process.
#[derive(Debug)]
pub struct DisplayListBuilder {
    pipeline_id: PipelineId,
    frame_id: FrameId,
    list: Vec<DisplayItem>,

    clip_len: usize,
    space_len: usize,
    stack_ctx_len: usize,
}
impl DisplayListBuilder {
    /// New default.
    pub fn new(pipeline_id: PipelineId, frame_id: FrameId) -> Self {
        Self::with_capacity(pipeline_id, frame_id, 100)
    }

    /// New with pre-allocation.
    pub fn with_capacity(pipeline_id: PipelineId, frame_id: FrameId, capacity: usize) -> Self {
        Self {
            pipeline_id,
            frame_id,
            list: Vec::with_capacity(capacity),

            clip_len: 1,
            space_len: 1,
            stack_ctx_len: 1,
        }
    }

    /// Pipeline that will render the display items.
    pub fn pipeline_id(&self) -> PipelineId {
        self.pipeline_id
    }

    /// Frame that will be rendered by this display list.
    pub fn frame_id(&self) -> FrameId {
        self.frame_id
    }

    /// Mark the start of a reuse range, the range can be completed with [`finish_reuse_range`].
    ///
    /// Reuse ranges can be nested.
    ///
    /// [`finish_reuse_range`]: Self::finish_reuse_range
    pub fn start_reuse_range(&mut self) -> ReuseStart {
        ReuseStart {
            pipeline_id: self.pipeline_id,
            frame_id: self.frame_id,
            start: self.list.len(),
            clip_len: self.clip_len,
            space_len: self.space_len,
            stack_ctx_len: self.stack_ctx_len,
        }
    }

    /// Mark the end of a reuse range.
    ///
    /// Panics if `start` was not generated by a call to [`start_reuse_range`] on the same builder, or clips, reference frames or
    /// stacking contexts where pushed inside it and not popped before the call to finish.
    ///
    /// [`start_reuse_range`]: Self::start_reuse_range
    pub fn finish_reuse_range(&mut self, start: ReuseStart) -> ReuseRange {
        assert_eq!(self.pipeline_id, start.pipeline_id, "reuse range not started by the same builder");
        assert_eq!(self.frame_id, start.frame_id, "reuse range not started by the same builder");
        assert_eq!(
            self.clip_len, start.clip_len,
            "reuse range cannot finish before all clips pushed inside it are popped"
        );
        assert_eq!(
            self.space_len, start.space_len,
            "reuse range cannot finish before all reference frames pushed inside it are popped"
        );
        assert_eq!(
            self.stack_ctx_len, start.stack_ctx_len,
            "reuse range cannot finish before all stacking contexts pushed inside it are popped"
        );
        debug_assert!(start.start <= self.list.len());

        ReuseRange {
            pipeline_id: self.pipeline_id,
            frame_id: self.frame_id,
            start: start.start,
            end: self.list.len(),
        }
    }

    /// Push a range of items to be copied from the previous display list on the same pipeline.
    ///
    /// Panics if `range` does not have a compatible pipeline id.
    pub fn push_reuse_range(&mut self, range: &ReuseRange) {
        assert_eq!(self.pipeline_id, range.pipeline_id);

        if !range.is_empty() {
            self.list.push(DisplayItem::Reuse {
                frame_id: range.frame_id,
                start: range.start,
                end: range.end,
            });
        }
    }

    /// Start a new spatial context, must be paired with a call to [`pop_reference_frame`].
    ///
    /// [`pop_reference_frame`]: Self::pop_reference_frame
    pub fn push_reference_frame(
        &mut self,
        key: wr::SpatialTreeItemKey,
        transform: wr::PropertyBinding<wr::units::LayoutTransform>,
        is_2d_scale_translation: bool,
    ) {
        self.space_len += 1;
        self.list.push(DisplayItem::PushReferenceFrame {
            key,
            transform,
            is_2d_scale_translation,
        });
    }

    /// Finish the spatial context started by a call to [`push_reference_frame`].
    ///
    /// [`push_reference_frame`]: Self::push_reference_frame
    pub fn pop_reference_frame(&mut self) {
        debug_assert!(self.space_len > 1);
        self.space_len -= 1;
        self.list.push(DisplayItem::PopReferenceFrame);
    }

    /// Start a new filters context, must be paired with a call to [`pop_stacking_context`].
    ///
    /// [`pop_stacking_context`]: Self::pop_stacking_context
    pub fn push_stacking_context(
        &mut self,
        blend_mode: wr::MixBlendMode,
        filters: &[wr::FilterOp],
        filter_datas: &[wr::FilterData],
        filter_primitives: &[wr::FilterPrimitive],
    ) {
        self.stack_ctx_len += 1;
        self.list.push(DisplayItem::PushStackingContext {
            blend_mode,
            filters: filters.to_vec().into_boxed_slice(),
            filter_datas: filter_datas.to_vec().into_boxed_slice(),
            filter_primitives: filter_primitives.to_vec().into_boxed_slice(),
        })
    }

    /// Finish the filters context started by a call to [`push_stacking_context`].
    ///
    /// [`push_stacking_context`]: Self::push_stacking_context
    pub fn pop_stacking_context(&mut self) {
        debug_assert!(self.stack_ctx_len > 1);
        self.stack_ctx_len -= 1;
        self.list.push(DisplayItem::PopStackingContext);
    }

    /// Push a rectangular clip that will affect all pushed items until a paired call to [`pop_clip`].
    ///
    /// [`pop_clip`]: Self::pop_clip
    pub fn push_clip_rect(&mut self, clip_rect: PxRect) {
        self.clip_len += 1;
        self.list.push(DisplayItem::PushClipRect { clip_rect });
    }

    /// Push a rectangular clip with rounded corners that will affect all pushed items until a paired call to [`pop_clip`].
    ///
    /// If `clip_out` is `true` only pixels outside the rounded rect are visible.
    ///
    /// [`pop_clip`]: Self::pop_clip
    pub fn push_clip_rounded_rect(&mut self, clip_rect: PxRect, corners: PxCornerRadius, clip_out: bool) {
        self.clip_len += 1;
        self.list.push(DisplayItem::PushClipRoundedRect {
            clip_rect,
            corners,
            clip_out,
        });
    }

    /// Pop a clip previously pushed by a call to [`push_clip_rect`]. Items pushed after this call are not
    /// clipped by the removed clip.
    ///
    /// [`push_clip_rect`]: Self::push_clip_rect
    pub fn pop_clip(&mut self) {
        debug_assert!(self.clip_len > 1);
        self.clip_len -= 1;
        self.list.push(DisplayItem::PopClip);
    }

    /// Push a normal border.
    #[allow(clippy::too_many_arguments)]
    pub fn push_border(
        &mut self,
        bounds: PxRect,
        widths: PxSideOffsets,
        top: wr::BorderSide,
        right: wr::BorderSide,
        bottom: wr::BorderSide,
        left: wr::BorderSide,
        radius: PxCornerRadius,
    ) {
        self.list.push(DisplayItem::Border {
            bounds,
            widths,
            sides: [top, right, bottom, left],
            radius,
        })
    }

    /// Push a text run.
    pub fn push_text(
        &mut self,
        clip_rect: PxRect,
        font_key: wr::FontInstanceKey,
        glyphs: &[wr::GlyphInstance],
        color: wr::ColorF,
        options: wr::GlyphOptions,
    ) {
        self.list.push(DisplayItem::Text {
            clip_rect,
            font_key,
            glyphs: glyphs.to_vec().into_boxed_slice(),
            color,
            options,
        });
    }

    /// Push an image.
    pub fn push_image(
        &mut self,
        clip_rect: PxRect,
        image_key: wr::ImageKey,
        image_size: PxSize,
        rendering: wr::ImageRendering,
        alpha_type: wr::AlphaType,
    ) {
        self.list.push(DisplayItem::Image {
            clip_rect,
            image_key,
            image_size,
            rendering,
            alpha_type,
        })
    }

    /// Push a color rectangle.
    pub fn push_color(&mut self, clip_rect: PxRect, color: wr::PropertyBinding<wr::ColorF>) {
        self.list.push(DisplayItem::Color { clip_rect, color })
    }

    /// Push a linear gradient rectangle.
    pub fn push_linear_gradient(
        &mut self,
        clip_rect: PxRect,
        gradient: wr::Gradient,
        stops: &[wr::GradientStop],
        tile_size: PxSize,
        tile_spacing: PxSize,
    ) {
        self.list.push(DisplayItem::LinearGradient {
            clip_rect,
            gradient,
            stops: stops.to_vec().into_boxed_slice(),
            tile_size,
            tile_spacing,
        })
    }

    /// Push a radial gradient rectangle.
    pub fn push_radial_gradient(
        &mut self,
        clip_rect: PxRect,
        gradient: wr::RadialGradient,
        stops: &[wr::GradientStop],
        tile_size: PxSize,
        tile_spacing: PxSize,
    ) {
        self.list.push(DisplayItem::RadialGradient {
            clip_rect,
            gradient,
            stops: stops.to_vec().into_boxed_slice(),
            tile_size,
            tile_spacing,
        });
    }

    /// Push a conic gradient rectangle.
    pub fn push_conic_gradient(
        &mut self,
        clip_rect: PxRect,
        gradient: wr::ConicGradient,
        stops: &[wr::GradientStop],
        tile_size: PxSize,
        tile_spacing: PxSize,
    ) {
        self.list.push(DisplayItem::ConicGradient {
            clip_rect,
            gradient,
            stops: stops.to_vec().into_boxed_slice(),
            tile_size,
            tile_spacing,
        });
    }

    /// Push a styled vertical or horizontal line.
    pub fn push_line(
        &mut self,
        clip_rect: PxRect,
        color: wr::ColorF,
        style: wr::LineStyle,
        wavy_line_thickness: f32,
        orientation: wr::LineOrientation,
    ) {
        self.list.push(DisplayItem::Line {
            clip_rect,
            color,
            style,
            wavy_line_thickness,
            orientation,
        })
    }

    /// Number of display items.
    pub fn len(&self) -> usize {
        self.list.len()
    }

    /// Returns `true` if the list has no display items.
    pub fn is_empty(&self) -> bool {
        self.list.is_empty()
    }

    /// Returns the display list an capacity suggestion for the next frame.
    pub fn finalize(self) -> (DisplayList, usize) {
        let cap = self.list.len();
        (
            DisplayList {
                pipeline_id: self.pipeline_id,
                frame_id: self.frame_id,
                list: self.list,
            },
            cap,
        )
    }
}

/// Represents the start of a display list reuse range.
///
/// See [`DisplayListBuilder::start_reuse_range`] for more details.
pub struct ReuseStart {
    pipeline_id: PipelineId,
    frame_id: FrameId,
    start: usize,

    clip_len: usize,
    space_len: usize,
    stack_ctx_len: usize,
}

/// Represents a display list reuse range.
///
/// See [`DisplayListBuilder::push_reuse_range`] for more details.
pub struct ReuseRange {
    pipeline_id: PipelineId,
    frame_id: FrameId,
    start: usize,
    end: usize,
}
impl ReuseRange {
    /// Pipeline where the items can be reused.
    pub fn pipeline_id(&self) -> PipelineId {
        self.pipeline_id
    }

    /// If the reuse range did not capture any display item.
    pub fn is_empty(&self) -> bool {
        self.start == self.end
    }
}

/// Represents a finalized display list.
///
/// See [`DisplayListBuilder::finalize`] for more details.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisplayList {
    pipeline_id: PipelineId,
    frame_id: FrameId,
    list: Vec<DisplayItem>,
}
impl DisplayList {
    /// Pipeline that will render the display items.
    pub fn pipeline_id(&self) -> PipelineId {
        self.pipeline_id
    }

    /// Frame that will be rendered by this display list.
    pub fn frame_id(&self) -> FrameId {
        self.frame_id
    }

    /// Convert the display list to a webrender display list, including the reuse items.
    pub fn to_webrender(self, cache: &mut DisplayListCache) -> wr::BuiltDisplayList {
        assert_eq!(self.pipeline_id, cache.pipeline_id);

        let mut wr_list = wr::DisplayListBuilder::new(self.pipeline_id);
        wr_list.begin();

        let mut sc = cache.take_space_and_clip();

        for item in &self.list {
            item.to_webrender(&mut wr_list, &mut sc, cache);
        }
        cache.insert(self, sc);
        wr_list.end().1
    }
}

struct CachedDisplayList {
    list: Vec<DisplayItem>,
    used: Cell<bool>,
}

/// View process side cache of [`DisplayList`] frames for a pipeline.
pub struct DisplayListCache {
    pipeline_id: PipelineId,
    lists: LinearMap<FrameId, CachedDisplayList>,
    space_and_clip: SpaceAndClip,
}
impl DisplayListCache {
    /// New empty.
    pub fn new(pipeline_id: PipelineId) -> Self {
        DisplayListCache {
            pipeline_id,
            lists: LinearMap::new(),
            space_and_clip: SpaceAndClip::new(pipeline_id),
        }
    }

    fn take_space_and_clip(&mut self) -> SpaceAndClip {
        mem::replace(&mut self.space_and_clip, SpaceAndClip::new(self.pipeline_id))
    }

    /// Pipeline where the items can be reused.
    pub fn pipeline_id(&self) -> PipelineId {
        self.pipeline_id
    }

    fn reuse(&self, frame_id: FrameId, start: usize, end: usize, wr_list: &mut wr::DisplayListBuilder, sc: &mut SpaceAndClip) {
        if let Some(l) = self.lists.get(&frame_id) {
            l.used.set(true);

            let range = l.list.get(start..end).unwrap_or_else(|| {
                tracing::error!("invalid reuse range ({start}..{end}), ignored");
                &[]
            });
            for item in range {
                item.to_webrender(wr_list, sc, self);
            }
        } else {
            panic!("did not find reuse frame {frame_id:?}");
        }
    }

    fn insert(&mut self, list: DisplayList, sc: SpaceAndClip) {
        assert_eq!(1, sc.spatial.len());
        assert_eq!(1, sc.clip.len());
        self.space_and_clip = sc;

        self.lists.retain(|_, l| l.used.take());
        self.lists.insert(
            list.frame_id,
            CachedDisplayList {
                list: list.list,
                used: Cell::new(false),
            },
        );
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum DisplayItem {
    Reuse {
        frame_id: FrameId,
        start: usize,
        end: usize,
    },
    PushReferenceFrame {
        key: wr::SpatialTreeItemKey,
        transform: wr::PropertyBinding<wr::units::LayoutTransform>,
        is_2d_scale_translation: bool,
    },
    PopReferenceFrame,

    PushStackingContext {
        blend_mode: wr::MixBlendMode,
        filters: Box<[wr::FilterOp]>,
        filter_datas: Box<[wr::FilterData]>,
        filter_primitives: Box<[wr::FilterPrimitive]>,
    },
    PopStackingContext,

    PushClipRect {
        clip_rect: PxRect,
    },
    PushClipRoundedRect {
        clip_rect: PxRect,
        corners: PxCornerRadius,
        clip_out: bool,
    },
    PopClip,

    Border {
        bounds: PxRect,
        widths: PxSideOffsets,
        sides: [wr::BorderSide; 4],
        radius: PxCornerRadius,
    },

    Text {
        clip_rect: PxRect,
        font_key: wr::FontInstanceKey,
        glyphs: Box<[wr::GlyphInstance]>,
        color: wr::ColorF,
        options: wr::GlyphOptions,
    },

    Image {
        clip_rect: PxRect,
        image_key: wr::ImageKey,
        image_size: PxSize,
        rendering: wr::ImageRendering,
        alpha_type: wr::AlphaType,
    },

    Color {
        clip_rect: PxRect,
        color: wr::PropertyBinding<wr::ColorF>,
    },

    LinearGradient {
        clip_rect: PxRect,
        gradient: wr::Gradient,
        stops: Box<[wr::GradientStop]>,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },
    RadialGradient {
        clip_rect: PxRect,
        gradient: wr::RadialGradient,
        stops: Box<[wr::GradientStop]>,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },
    ConicGradient {
        clip_rect: PxRect,
        gradient: wr::ConicGradient,
        stops: Box<[wr::GradientStop]>,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },

    Line {
        clip_rect: PxRect,
        color: wr::ColorF,
        style: wr::LineStyle,
        wavy_line_thickness: f32,
        orientation: wr::LineOrientation,
    },
}
impl DisplayItem {
    fn to_webrender(&self, wr_list: &mut wr::DisplayListBuilder, sc: &mut SpaceAndClip, cache: &DisplayListCache) {
        match self {
            DisplayItem::Reuse { frame_id, start, end } => cache.reuse(*frame_id, *start, *end, wr_list, sc),

            DisplayItem::PushReferenceFrame {
                key,
                transform,
                is_2d_scale_translation,
            } => {
                let spatial_id = wr_list.push_reference_frame(
                    wr::units::LayoutPoint::zero(),
                    sc.spatial_id(),
                    wr::TransformStyle::Flat,
                    *transform,
                    wr::ReferenceFrameKind::Transform {
                        is_2d_scale_translation: *is_2d_scale_translation,
                        should_snap: false,
                        paired_with_perspective: false,
                    },
                    *key,
                );
                sc.spatial.push(spatial_id);
            }
            DisplayItem::PopReferenceFrame => {
                wr_list.pop_reference_frame();
                sc.pop_spatial();
            }

            DisplayItem::PushStackingContext {
                blend_mode,
                filters,
                filter_datas,
                filter_primitives,
            } => wr_list.push_stacking_context(
                wr::units::LayoutPoint::zero(),
                sc.spatial_id(),
                wr::PrimitiveFlags::empty(),
                Some(sc.clip_id()),
                wr::TransformStyle::Flat,
                *blend_mode,
                filters,
                filter_datas,
                filter_primitives,
                wr::RasterSpace::Screen,
                wr::StackingContextFlags::empty(),
            ),
            DisplayItem::PopStackingContext => wr_list.pop_stacking_context(),

            DisplayItem::PushClipRect { clip_rect } => {
                let clip_id = wr_list.define_clip_rect(&sc.info(), clip_rect.to_wr());
                sc.clip.push(clip_id);
            }
            DisplayItem::PushClipRoundedRect {
                clip_rect,
                corners,
                clip_out,
            } => {
                let clip_id = wr_list.define_clip_rounded_rect(
                    &sc.info(),
                    wr::ComplexClipRegion::new(
                        clip_rect.to_wr(),
                        corners.to_wr(),
                        if *clip_out { wr::ClipMode::ClipOut } else { wr::ClipMode::Clip },
                    ),
                );
                sc.clip.push(clip_id);
            }
            DisplayItem::PopClip => sc.pop_clip(),

            DisplayItem::Text {
                clip_rect,
                font_key,
                glyphs,
                color,
                options,
            } => {
                let bounds = clip_rect.to_wr();
                wr_list.push_text(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    bounds,
                    glyphs,
                    *font_key,
                    *color,
                    Some(*options),
                );
            }

            DisplayItem::Color { clip_rect, color } => {
                let bounds = clip_rect.to_wr();
                wr_list.push_rect_with_animation(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    bounds,
                    *color,
                )
            }

            DisplayItem::Border {
                bounds,
                widths,
                sides: [top, right, bottom, left],
                radius,
            } => {
                let bounds = bounds.to_wr();
                wr_list.push_border(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    bounds,
                    widths.to_wr(),
                    wr::BorderDetails::Normal(wr::NormalBorder {
                        left: *left,
                        right: *right,
                        top: *top,
                        bottom: *bottom,
                        radius: radius.to_wr(),
                        do_aa: true,
                    }),
                );
            }

            DisplayItem::Image {
                clip_rect,
                image_key,
                image_size,
                rendering,
                alpha_type,
            } => {
                let bounds = clip_rect.to_wr();
                wr_list.push_image(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    PxRect::from_size(*image_size).to_wr(),
                    *rendering,
                    *alpha_type,
                    *image_key,
                    wr::ColorF::WHITE,
                );
            }

            DisplayItem::LinearGradient {
                clip_rect,
                gradient,
                stops,
                tile_size,
                tile_spacing,
            } => {
                wr_list.push_stops(stops);
                let bounds = clip_rect.to_wr();
                wr_list.push_gradient(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    bounds,
                    *gradient,
                    tile_size.to_wr(),
                    tile_spacing.to_wr(),
                )
            }
            DisplayItem::RadialGradient {
                clip_rect,
                gradient,
                stops,
                tile_size,
                tile_spacing,
            } => {
                wr_list.push_stops(stops);
                let bounds = clip_rect.to_wr();
                wr_list.push_radial_gradient(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    bounds,
                    *gradient,
                    tile_size.to_wr(),
                    tile_spacing.to_wr(),
                )
            }
            DisplayItem::ConicGradient {
                clip_rect,
                gradient,
                stops,
                tile_size,
                tile_spacing,
            } => {
                wr_list.push_stops(stops);
                let bounds = clip_rect.to_wr();
                wr_list.push_conic_gradient(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    bounds,
                    *gradient,
                    tile_size.to_wr(),
                    tile_spacing.to_wr(),
                )
            }
            DisplayItem::Line {
                clip_rect,
                color,
                style,
                wavy_line_thickness,
                orientation,
            } => {
                let bounds = clip_rect.to_wr();
                wr_list.push_line(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_id: sc.clip_id(),
                        spatial_id: sc.spatial_id(),
                        flags: wr::PrimitiveFlags::empty(),
                    },
                    &bounds,
                    *wavy_line_thickness,
                    *orientation,
                    color,
                    *style,
                );
            }
        }
    }
}

struct SpaceAndClip {
    spatial: Vec<wr::SpatialId>,
    clip: Vec<wr::ClipId>,
}
impl SpaceAndClip {
    pub fn new(pipeline_id: PipelineId) -> Self {
        let sid = wr::SpatialId::root_reference_frame(pipeline_id);
        let cid = wr::ClipId::root(pipeline_id);
        SpaceAndClip {
            spatial: vec![sid],
            clip: vec![cid],
        }
    }

    pub fn clip_id(&self) -> wr::ClipId {
        self.clip[self.clip.len() - 1]
    }

    pub fn spatial_id(&self) -> wr::SpatialId {
        self.spatial[self.spatial.len() - 1]
    }

    pub fn info(&self) -> wr::SpaceAndClipInfo {
        wr::SpaceAndClipInfo {
            spatial_id: self.spatial_id(),
            clip_id: self.clip_id(),
        }
    }

    pub fn pop_spatial(&mut self) {
        self.spatial.truncate(self.spatial.len() - 1);
    }

    pub fn pop_clip(&mut self) {
        self.clip.truncate(self.clip.len() - 1);
    }
}
