//! Frame builder types.

use std::{
    cell::Cell,
    mem,
    sync::{atomic::AtomicUsize, Arc},
};

use rustc_hash::FxHashMap;
use serde::{Deserialize, Serialize};
use webrender_api::{self as wr, PipelineId};

use crate::{
    api_extension::{ApiExtensionId, ApiExtensionPayload},
    font::{cast_glyphs_to_wr, FontId, GlyphInstance, GlyphOptions},
    image::ImageTextureId,
    unit::PxToWr,
    window::FrameId,
    BorderSide, GradientStop,
};
use zero_ui_unit::*;

/// Represents a builder for display items that will be rendered in the view process.
#[derive(Debug)]
pub struct DisplayListBuilder {
    frame_id: FrameId,
    list: Vec<DisplayItem>,

    clip_len: usize,
    mask_len: usize,
    space_len: usize,
    stacking_len: usize,

    seg_id: SegmentId,
    seg_id_gen: Arc<AtomicUsize>,
    segments: Vec<(SegmentId, usize)>,
    has_reuse_ranges: bool,
}
impl DisplayListBuilder {
    /// New default.
    pub fn new(frame_id: FrameId) -> Self {
        Self::with_capacity(frame_id, 100)
    }

    /// New with pre-allocation.
    pub fn with_capacity(frame_id: FrameId, capacity: usize) -> Self {
        Self {
            frame_id,
            list: Vec::with_capacity(capacity),

            clip_len: 1,
            mask_len: 1,
            space_len: 1,
            stacking_len: 1,
            seg_id: 0,
            seg_id_gen: Arc::new(AtomicUsize::new(1)),
            segments: vec![(0, 0)],
            has_reuse_ranges: false,
        }
    }

    /// Frame that will be rendered by this display list.
    pub fn frame_id(&self) -> FrameId {
        self.frame_id
    }

    /// Mark the start of a reuse range, the range can be completed with [`finish_reuse_range`].
    ///
    /// Reuse ranges can be nested.
    ///
    /// [`finish_reuse_range`]: Self::finish_reuse_range
    pub fn start_reuse_range(&mut self) -> ReuseStart {
        ReuseStart {
            frame_id: self.frame_id,
            seg_id: self.seg_id,
            start: self.list.len(),
            clip_len: self.clip_len,
            mask_len: self.mask_len,
            space_len: self.space_len,
            stacking_len: self.stacking_len,
        }
    }

    /// Mark the end of a reuse range.
    ///
    /// Panics if `start` was not generated by a call to [`start_reuse_range`] on the same builder, or clips, masks, reference frames or
    /// stacking contexts where pushed inside it and not popped before the call to finish.
    ///
    /// [`start_reuse_range`]: Self::start_reuse_range
    pub fn finish_reuse_range(&mut self, start: ReuseStart) -> ReuseRange {
        assert_eq!(self.frame_id, start.frame_id, "reuse range not started by the same builder");
        assert_eq!(self.seg_id, start.seg_id, "reuse range not started by the same builder");
        assert_eq!(
            self.clip_len, start.clip_len,
            "reuse range cannot finish before all clips pushed inside it are popped"
        );
        assert_eq!(
            self.mask_len, start.mask_len,
            "reuse range cannot finish before all masks pushed inside it are popped"
        );
        assert_eq!(
            self.space_len, start.space_len,
            "reuse range cannot finish before all reference frames pushed inside it are popped"
        );
        assert_eq!(
            self.stacking_len, start.stacking_len,
            "reuse range cannot finish before all stacking contexts pushed inside it are popped"
        );
        debug_assert!(start.start <= self.list.len());

        self.has_reuse_ranges = true;

        ReuseRange {
            frame_id: self.frame_id,
            seg_id: self.seg_id,
            start: start.start,
            end: self.list.len(),
        }
    }

    /// Push a range of items to be copied from the previous display list on the same pipeline.
    ///
    /// Panics if `range` does not have a compatible pipeline id.
    pub fn push_reuse_range(&mut self, range: &ReuseRange) {
        if !range.is_empty() {
            self.list.push(DisplayItem::Reuse {
                frame_id: range.frame_id,
                seg_id: range.seg_id,
                start: range.start,
                end: range.end,
            });
        }
    }

    /// Start a new spatial context, must be paired with a call to [`pop_reference_frame`].
    ///
    /// If `transform_style` is `Preserve3D` if extends the 3D context of the parent. If the parent
    /// is not `Preserve3D` a stacking context with `Preserve3D` must be the next display item.
    ///
    /// [`pop_reference_frame`]: Self::pop_reference_frame
    pub fn push_reference_frame(
        &mut self,
        key: wr::SpatialTreeItemKey,
        transform: FrameValue<PxTransform>,
        transform_style: wr::TransformStyle,
        is_2d_scale_translation: bool,
    ) {
        self.space_len += 1;
        self.list.push(DisplayItem::PushReferenceFrame {
            key,
            transform,
            transform_style,
            is_2d_scale_translation,
        });
    }

    /// Finish the flat spatial context started by a call to [`push_reference_frame`].
    ///
    /// [`push_reference_frame`]: Self::push_reference_frame
    pub fn pop_reference_frame(&mut self) {
        debug_assert!(self.space_len > 1);
        self.space_len -= 1;
        self.list.push(DisplayItem::PopReferenceFrame);
    }

    /// Start a new filters context or extend 3D space, must be paired with a call to [`pop_stacking_context`].
    ///
    /// Note that `transform_style` is coerced to `Flat` if any filter is also set.
    ///
    /// [`pop_stacking_context`]: Self::pop_stacking_context
    pub fn push_stacking_context(
        &mut self,
        blend_mode: wr::MixBlendMode,
        transform_style: wr::TransformStyle,
        filters: &[FilterOp],
        filter_datas: &[wr::FilterData],
        filter_primitives: &[wr::FilterPrimitive],
    ) {
        self.stacking_len += 1;
        self.list.push(DisplayItem::PushStackingContext {
            blend_mode,
            transform_style,
            filters: filters.to_vec().into_boxed_slice(),
            filter_datas: filter_datas.to_vec().into_boxed_slice(),
            filter_primitives: filter_primitives.to_vec().into_boxed_slice(),
        })
    }

    /// Finish the filters context started by a call to [`push_stacking_context`].
    ///
    /// [`push_stacking_context`]: Self::push_stacking_context
    pub fn pop_stacking_context(&mut self) {
        debug_assert!(self.stacking_len > 1);
        self.stacking_len -= 1;
        self.list.push(DisplayItem::PopStackingContext);
    }

    /// Push a rectangular clip that will affect all pushed items until a paired call to [`pop_clip`].
    ///
    /// [`pop_clip`]: Self::pop_clip
    pub fn push_clip_rect(&mut self, clip_rect: PxRect, clip_out: bool) {
        self.clip_len += 1;
        self.list.push(DisplayItem::PushClipRect { clip_rect, clip_out });
    }

    /// Push a rectangular clip with rounded corners that will affect all pushed items until a paired call to [`pop_clip`].
    ///
    /// If `clip_out` is `true` only pixels outside the rounded rect are visible.
    ///
    /// [`pop_clip`]: Self::pop_clip
    pub fn push_clip_rounded_rect(&mut self, clip_rect: PxRect, corners: PxCornerRadius, clip_out: bool) {
        self.clip_len += 1;
        self.list.push(DisplayItem::PushClipRoundedRect {
            clip_rect,
            corners,
            clip_out,
        });
    }

    /// Pop a clip previously pushed by a call to [`push_clip_rect`]. Items pushed after this call are not
    /// clipped.
    ///
    /// [`push_clip_rect`]: Self::push_clip_rect
    pub fn pop_clip(&mut self) {
        debug_assert!(self.clip_len > 1);
        self.clip_len -= 1;
        self.list.push(DisplayItem::PopClip);
    }

    /// Push an image mask that will affect all pushed items until a paired call to [`pop_mask`].
    ///
    /// [`pop_mask`]: Self::pop_mask
    pub fn push_mask(&mut self, image_id: ImageTextureId, rect: PxRect) {
        self.mask_len += 1;
        self.list.push(DisplayItem::PushMask { image_id, rect })
    }

    /// Pop an image mask previously pushed by a call to [`push_mask`]. Items pushed after this call are not
    /// masked.
    ///
    /// [`push_mask`]: Self::push_mask
    pub fn pop_mask(&mut self) {
        debug_assert!(self.mask_len > 1);
        self.mask_len -= 1;
        self.list.push(DisplayItem::PopMask);
    }

    /// Push a normal border.
    #[allow(clippy::too_many_arguments)]
    pub fn push_border(
        &mut self,
        bounds: PxRect,
        widths: PxSideOffsets,
        top: BorderSide,
        right: BorderSide,
        bottom: BorderSide,
        left: BorderSide,
        radius: PxCornerRadius,
    ) {
        self.list.push(DisplayItem::Border {
            bounds,
            widths,
            sides: [top, right, bottom, left],
            radius,
        })
    }

    /// Push a nine-patch border.
    #[allow(clippy::too_many_arguments)]
    pub fn push_nine_patch_border(
        &mut self,
        bounds: PxRect,
        source: NinePatchSource,
        widths: PxSideOffsets,
        fill: bool,
        repeat_horizontal: wr::RepeatMode,
        repeat_vertical: wr::RepeatMode,
    ) {
        self.list.push(DisplayItem::NinePatchBorder {
            bounds,
            source,
            widths,
            fill,
            repeat_horizontal,
            repeat_vertical,
        })
    }

    /// Push a text run.
    pub fn push_text(
        &mut self,
        clip_rect: PxRect,
        font_id: FontId,
        glyphs: &[GlyphInstance],
        color: FrameValue<Rgba>,
        options: GlyphOptions,
    ) {
        self.list.push(DisplayItem::Text {
            clip_rect,
            font_id,
            glyphs: glyphs.to_vec().into_boxed_slice(),
            color,
            options,
        });
    }

    /// Push an image.
    #[allow(clippy::too_many_arguments)]
    pub fn push_image(
        &mut self,
        clip_rect: PxRect,
        image_id: ImageTextureId,
        image_size: PxSize,
        tile_size: PxSize,
        tile_spacing: PxSize,
        rendering: wr::ImageRendering,
        alpha_type: wr::AlphaType,
    ) {
        self.list.push(DisplayItem::Image {
            clip_rect,
            image_id,
            image_size,
            rendering,
            alpha_type,
            tile_size,
            tile_spacing,
        })
    }

    /// Push a color rectangle.
    pub fn push_color(&mut self, clip_rect: PxRect, color: FrameValue<Rgba>) {
        self.list.push(DisplayItem::Color { clip_rect, color })
    }

    /// Push a filter that applies to all rendered pixels behind `clip_rect`.
    pub fn push_backdrop_filter(
        &mut self,
        clip_rect: PxRect,
        filters: &[FilterOp],
        filter_datas: &[wr::FilterData],
        filter_primitives: &[wr::FilterPrimitive],
    ) {
        self.list.push(DisplayItem::BackdropFilter {
            clip_rect,
            filters: filters.to_vec().into_boxed_slice(),
            filter_datas: filter_datas.to_vec().into_boxed_slice(),
            filter_primitives: filter_primitives.to_vec().into_boxed_slice(),
        })
    }

    /// Push a linear gradient rectangle.
    pub fn push_linear_gradient(
        &mut self,
        clip_rect: PxRect,
        gradient: wr::Gradient,
        stops: &[GradientStop],
        tile_origin: PxPoint,
        tile_size: PxSize,
        tile_spacing: PxSize,
    ) {
        self.list.push(DisplayItem::LinearGradient {
            clip_rect,
            gradient,
            stops: stops.to_vec().into_boxed_slice(),
            tile_origin,
            tile_size,
            tile_spacing,
        })
    }

    /// Push a radial gradient rectangle.
    pub fn push_radial_gradient(
        &mut self,
        clip_rect: PxRect,
        gradient: wr::RadialGradient,
        stops: &[GradientStop],
        tile_origin: PxPoint,
        tile_size: PxSize,
        tile_spacing: PxSize,
    ) {
        self.list.push(DisplayItem::RadialGradient {
            clip_rect,
            gradient,
            stops: stops.to_vec().into_boxed_slice(),
            tile_origin,
            tile_size,
            tile_spacing,
        });
    }

    /// Push a conic gradient rectangle.
    pub fn push_conic_gradient(
        &mut self,
        clip_rect: PxRect,
        gradient: wr::ConicGradient,
        stops: &[GradientStop],
        tile_origin: PxPoint,
        tile_size: PxSize,
        tile_spacing: PxSize,
    ) {
        self.list.push(DisplayItem::ConicGradient {
            clip_rect,
            gradient,
            stops: stops.to_vec().into_boxed_slice(),
            tile_origin,
            tile_size,
            tile_spacing,
        });
    }

    /// Push a styled vertical or horizontal line.
    pub fn push_line(
        &mut self,
        clip_rect: PxRect,
        color: Rgba,
        style: wr::LineStyle,
        wavy_line_thickness: f32,
        orientation: wr::LineOrientation,
    ) {
        self.list.push(DisplayItem::Line {
            clip_rect,
            color,
            style,
            wavy_line_thickness,
            orientation,
        })
    }

    /// Push a custom extension payload.
    ///
    /// This can be used by custom renderer implementations to support custom items defined in the context
    /// of normal display items.
    ///
    /// There are two types of display items, normal items like [`push_color`] and context items like
    /// [`push_clip_rect`]-[`pop_clip`], if the extension is a normal item only the `push_extension` method must
    /// be called, if the extension is a context item the [`pop_extension`] must also be called.
    ///
    /// [`push_color`]: Self::push_color
    /// [`push_clip_rect`]: Self::push_clip_rect
    /// [`pop_clip`]: Self::pop_clip
    /// [`pop_extension`]: Self::pop_extension
    pub fn push_extension(&mut self, extension_id: ApiExtensionId, payload: ApiExtensionPayload) {
        self.list.push(DisplayItem::PushExtension { extension_id, payload })
    }

    /// Pop an extension previously pushed.
    ///
    /// Only required if the extension implementation requires it, item extensions do not need to pop.
    pub fn pop_extension(&mut self, extension_id: ApiExtensionId) {
        self.list.push(DisplayItem::PopExtension { extension_id })
    }

    /// Sets the backface visibility of all display items after this call.
    pub fn set_backface_visibility(&mut self, visible: bool) {
        self.list.push(DisplayItem::SetBackfaceVisibility { visible })
    }

    /// Number of display items.
    pub fn len(&self) -> usize {
        self.list.len()
    }

    /// Returns `true` if the list has no display items.
    pub fn is_empty(&self) -> bool {
        self.list.is_empty()
    }

    /// Create a display list builder that can be send to be build in parallel and then folded back onto
    /// this list using [`parallel_fold`].
    ///
    /// [`parallel_fold`]: Self::parallel_fold
    pub fn parallel_split(&self) -> Self {
        Self {
            frame_id: self.frame_id,
            list: vec![],
            clip_len: 1,
            mask_len: 1,
            space_len: 1,
            stacking_len: 1,
            seg_id: self.seg_id_gen.fetch_add(1, std::sync::atomic::Ordering::Relaxed),
            seg_id_gen: self.seg_id_gen.clone(),
            segments: vec![],
            has_reuse_ranges: false,
        }
    }

    /// Append the `split` onto `self`.
    ///
    /// # Panics
    ///
    /// Panics if `split` was not generated by a call to [`parallel_split`] on `self` or a
    /// *parent* display list.
    ///
    /// Panics if `split` has not closed all reference frames, clips or stacking contexts that it opened.
    ///
    /// [`parallel_split`]: Self::parallel_split
    pub fn parallel_fold(&mut self, mut split: Self) {
        assert!(
            Arc::ptr_eq(&self.seg_id_gen, &split.seg_id_gen),
            "cannot fold list not split from this one or parent"
        );
        assert_eq!(split.space_len, 1);
        assert_eq!(split.clip_len, 1);
        assert_eq!(split.mask_len, 1);
        assert_eq!(split.stacking_len, 1);

        if !self.list.is_empty() {
            for (_, offset) in &mut split.segments {
                *offset += self.list.len();
            }
        }

        if self.segments.is_empty() {
            self.segments = split.segments;
        } else {
            self.segments.append(&mut split.segments);
        }
        if split.has_reuse_ranges {
            self.segments.push((split.seg_id, self.list.len()));
        }

        if self.list.is_empty() {
            self.list = split.list;
        } else {
            self.list.append(&mut split.list);
        }
    }

    /// Returns the display list.
    pub fn finalize(self) -> DisplayList {
        DisplayList {
            frame_id: self.frame_id,
            list: self.list,
            segments: self.segments,
        }
    }
}

/// Id of the offset a parallel list folded onto the main list is at.
type SegmentId = usize;

/// Represents the start of a display list reuse range.
///
/// See [`DisplayListBuilder::start_reuse_range`] for more details.
pub struct ReuseStart {
    frame_id: FrameId,
    seg_id: SegmentId,
    start: usize,

    clip_len: usize,
    mask_len: usize,
    space_len: usize,
    stacking_len: usize,
}

/// Represents a display list reuse range.
///
/// See [`DisplayListBuilder::push_reuse_range`] for more details.
#[derive(Debug, Clone)]
pub struct ReuseRange {
    frame_id: FrameId,
    seg_id: SegmentId,
    start: usize,
    end: usize,
}
impl ReuseRange {
    /// Frame that owns the reused items selected by this range.
    pub fn frame_id(&self) -> FrameId {
        self.frame_id
    }

    /// If the reuse range did not capture any display item.
    pub fn is_empty(&self) -> bool {
        self.start == self.end
    }
}

/// Represents a finalized display list.
///
/// See [`DisplayListBuilder::finalize`] for more details.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisplayList {
    frame_id: FrameId,
    list: Vec<DisplayItem>,
    segments: Vec<(SegmentId, usize)>,
}
impl DisplayList {
    /// Frame that will be rendered by this display list.
    pub fn frame_id(&self) -> FrameId {
        self.frame_id
    }

    /// Convert the display list to a webrender display list, including the reuse items.
    pub fn to_webrender(self, ext: &mut dyn DisplayListExtension, cache: &mut DisplayListCache) -> wr::BuiltDisplayList {
        let r = Self::build(&self.list, cache, ext, false);
        cache.insert(self);

        r
    }
    fn build(
        list: &[DisplayItem],
        cache: &mut DisplayListCache,
        ext: &mut dyn DisplayListExtension,
        is_reuse: bool,
    ) -> wr::BuiltDisplayList {
        let _s = tracing::trace_span!("DisplayList::build").entered();

        let (mut wr_list, mut sc) = cache.begin_wr();

        ext.display_list_start(&mut DisplayExtensionArgs {
            list: &mut wr_list,
            sc: &mut sc,
        });

        for item in list {
            item.to_webrender(&mut wr_list, ext, &mut sc, cache, is_reuse);
        }

        ext.display_list_end(&mut DisplayExtensionArgs {
            list: &mut wr_list,
            sc: &mut sc,
        });

        cache.end_wr(wr_list, sc)
    }
}

/// Frame value binding key.
///
/// See [`FrameValue`] for more details.
pub type FrameValueKey<T> = webrender_api::PropertyBindingKey<T>;

/// Represents a frame value that may be updated.
///
/// This value is send in a full frame request, after frame updates may be send targeting the key.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum FrameValue<T> {
    /// Value that is updated with frame update requests.
    Bind {
        /// Key that will be used to update the value.
        key: FrameValueKey<T>,
        /// Initial value.
        value: T,
        /// If the value will update rapidly.
        ///
        /// This affects if the frame binding will be propagated to webrender,
        /// see [`FrameValue::into_wr`] for details.
        animating: bool,
    },
    /// Value is not updated, a new frame must be send to change this value.
    Value(T),
}
impl<T> FrameValue<T> {
    /// Reference the (initial) value.
    pub fn value(&self) -> &T {
        match self {
            FrameValue::Bind { value, .. } | FrameValue::Value(value) => value,
        }
    }

    /// Into the (initial) value.
    pub fn into_value(self) -> T {
        match self {
            FrameValue::Bind { value, .. } | FrameValue::Value(value) => value,
        }
    }

    /// Convert to webrender binding.
    ///
    /// Returns a webrender binding only if is animating, webrender behaves as if the value is animating
    /// if it is bound, skipping some caching, this can have a large performance impact in software mode, if
    /// a large area of the screen is painted with a bound color.
    pub fn into_wr(self) -> wr::PropertyBinding<T::AsLayout>
    where
        T: PxToWr,
    {
        match self {
            FrameValue::Bind {
                key,
                value,
                animating: true,
            } => wr::PropertyBinding::Binding(
                wr::PropertyBindingKey {
                    id: key.id,
                    _phantom: std::marker::PhantomData,
                },
                value.to_wr(),
            ),
            FrameValue::Bind {
                value, animating: false, ..
            } => wr::PropertyBinding::Value(value.to_wr()),
            FrameValue::Value(value) => wr::PropertyBinding::Value(value.to_wr()),
        }
    }

    /// Returns `true` if a new frame must be generated.
    fn update_bindable(value: &mut T, animating: &mut bool, update: &FrameValueUpdate<T>) -> bool
    where
        T: PartialEq + Copy,
    {
        // if changed to `true`, needs a frame to register the binding.
        //
        // if changed to `false`, needs a frame to un-register the binding so that webrender can start caching
        // the tiles in the region again, we can't use the binding "one last time" because if a smaller region
        // continues animating it would keep refreshing the large region too.
        //
        // if continues to be `false` only needs to update if the value actually changed.
        let need_frame = (*animating != update.animating) || (!*animating && *value != update.value);

        *animating = update.animating;
        *value = update.value;

        need_frame
    }

    /// Returns `true` if a new frame must be generated.
    fn update_value(value: &mut T, update: &FrameValueUpdate<T>) -> bool
    where
        T: PartialEq + Copy,
    {
        if value != &update.value {
            *value = update.value;
            true
        } else {
            false
        }
    }
}
impl<T> From<T> for FrameValue<T> {
    fn from(value: T) -> Self {
        FrameValue::Value(value)
    }
}

/// Represents an update targeting a previously setup [`FrameValue`].
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct FrameValueUpdate<T> {
    /// Value key.
    pub key: FrameValueKey<T>,
    /// New value.
    pub value: T,
    /// If the value is updating rapidly.
    pub animating: bool,
}
impl<T> FrameValueUpdate<T> {
    /// Convert to webrender binding update.
    pub fn into_wr(self) -> Option<wr::PropertyValue<T::AsLayout>>
    where
        T: PxToWr,
    {
        if self.animating {
            Some(wr::PropertyValue {
                key: wr::PropertyBindingKey {
                    id: self.key.id,
                    _phantom: std::marker::PhantomData,
                },
                value: self.value.to_wr(),
            })
        } else {
            None
        }
    }
}

// to work with into_wr
impl PxToWr for f32 {
    type AsDevice = f32;

    type AsLayout = f32;

    type AsWorld = f32;

    fn to_wr_device(self) -> Self::AsDevice {
        self
    }

    fn to_wr_world(self) -> Self::AsWorld {
        self
    }

    fn to_wr(self) -> Self::AsLayout {
        self
    }
}
// to work with into_wr
impl PxToWr for Rgba {
    type AsDevice = wr::ColorF;

    type AsLayout = wr::ColorF;

    type AsWorld = wr::ColorF;

    fn to_wr_device(self) -> Self::AsDevice {
        self.to_wr()
    }

    fn to_wr_world(self) -> Self::AsWorld {
        self.to_wr()
    }

    fn to_wr(self) -> Self::AsLayout {
        wr::ColorF::new(self.red, self.green, self.blue, self.alpha)
    }
}

struct CachedDisplayList {
    list: Vec<DisplayItem>,
    segments: Vec<(SegmentId, usize)>,
    used: Cell<bool>,
}

/// View process side cache of [`DisplayList`] frames for a pipeline.
pub struct DisplayListCache {
    pipeline_id: PipelineId,
    id_namespace: wr::IdNamespace,
    lists: FxHashMap<FrameId, CachedDisplayList>,
    space_and_clip: Option<SpaceAndClip>,

    latest_frame: FrameId,
    bindings: FxHashMap<wr::PropertyBindingId, (FrameId, usize)>,

    wr_list: Option<wr::DisplayListBuilder>,
}
impl DisplayListCache {
    /// New empty.
    pub fn new(pipeline_id: PipelineId, id_namespace: wr::IdNamespace) -> Self {
        DisplayListCache {
            pipeline_id,
            id_namespace,
            lists: FxHashMap::default(),
            latest_frame: FrameId::INVALID,
            space_and_clip: Some(SpaceAndClip::new(pipeline_id)),
            bindings: FxHashMap::default(),
            wr_list: Some(wr::DisplayListBuilder::new(pipeline_id)),
        }
    }

    /// Pipeline where the items can be reused.
    pub fn pipeline_id(&self) -> PipelineId {
        self.pipeline_id
    }

    /// Keys namespace.
    pub fn id_namespace(&self) -> wr::IdNamespace {
        self.id_namespace
    }

    fn begin_wr(&mut self) -> (wr::DisplayListBuilder, SpaceAndClip) {
        let mut list = self.wr_list.take().unwrap();
        let sc = self.space_and_clip.take().unwrap();
        list.begin();
        (list, sc)
    }

    fn end_wr(&mut self, mut list: wr::DisplayListBuilder, mut sc: SpaceAndClip) -> wr::BuiltDisplayList {
        let r = list.end().1;
        self.wr_list = Some(list);
        sc.clear(self.pipeline_id);
        self.space_and_clip = Some(sc);
        r
    }

    #[allow(clippy::too_many_arguments)]
    fn reuse(
        &self,
        frame_id: FrameId,
        seg_id: SegmentId,
        mut start: usize,
        mut end: usize,
        wr_list: &mut wr::DisplayListBuilder,
        ext: &mut dyn DisplayListExtension,
        sc: &mut SpaceAndClip,
    ) {
        if let Some(l) = self.lists.get(&frame_id) {
            l.used.set(true);

            let offset = l
                .segments
                .iter()
                .find_map(|&(id, o)| if id == seg_id { Some(o) } else { None })
                .unwrap_or_else(|| {
                    tracing::error!("unknown segment id {seg_id}");
                    l.list.len()
                });
            start += offset;
            end += offset;

            let range = l.list.get(start..end).unwrap_or_else(|| {
                tracing::error!("invalid reuse range ({start}..{end}) ignored, offset: {offset}");
                &[]
            });
            for item in range {
                item.to_webrender(wr_list, ext, sc, self, true);
            }
        } else {
            tracing::error!("did not find reuse frame {frame_id:?}");
        }
    }

    fn insert(&mut self, list: DisplayList) {
        self.lists.retain(|_, l| l.used.take());

        for (i, item) in list.list.iter().enumerate() {
            item.register_bindings(&mut self.bindings, (list.frame_id, i));
        }

        self.latest_frame = list.frame_id;
        self.lists.insert(
            list.frame_id,
            CachedDisplayList {
                list: list.list,
                segments: list.segments,
                used: Cell::new(false),
            },
        );
    }

    fn get_update_target(&mut self, id: wr::PropertyBindingId) -> Option<&mut DisplayItem> {
        if let Some((frame_id, i)) = self.bindings.get(&id) {
            if let Some(list) = self.lists.get_mut(frame_id) {
                if let Some(item) = list.list.get_mut(*i) {
                    return Some(item);
                }
            }
        }
        None
    }

    /// Apply updates, returns the webrender update if the renderer can also be updated and there are any updates,
    /// or returns a new frame if a new frame must be rendered.
    #[allow(clippy::result_large_err)] // both are large
    pub fn update(
        &mut self,
        ext: &mut dyn DisplayListExtension,
        transforms: Vec<FrameValueUpdate<PxTransform>>,
        floats: Vec<FrameValueUpdate<f32>>,
        colors: Vec<FrameValueUpdate<Rgba>>,
        extensions: Vec<(ApiExtensionId, ApiExtensionPayload)>,
        resized: bool,
    ) -> Result<Option<wr::DynamicProperties>, wr::BuiltDisplayList> {
        let mut new_frame = resized;

        for t in &transforms {
            if let Some(item) = self.get_update_target(t.key.id) {
                new_frame |= item.update_transform(t);
            }
        }
        for t in &floats {
            if let Some(item) = self.get_update_target(t.key.id) {
                new_frame |= item.update_float(t);
            }
        }
        for t in &colors {
            if let Some(item) = self.get_update_target(t.key.id) {
                new_frame |= item.update_color(t);
            }
        }

        let mut properties = wr::DynamicProperties::default();

        for (k, e) in &extensions {
            let mut args = DisplayExtensionUpdateArgs {
                extension_id: *k,
                payload: e,
                new_frame: false,
                properties: &mut properties,
            };
            ext.update(&mut args);
            new_frame |= args.new_frame;
        }

        if new_frame {
            let list = self.lists.get_mut(&self.latest_frame).expect("no frame to update");
            let list = mem::take(&mut list.list);
            let r = DisplayList::build(&list, self, ext, true);
            self.lists.get_mut(&self.latest_frame).unwrap().list = list;

            Err(r)
        } else {
            properties
                .transforms
                .extend(transforms.into_iter().filter_map(FrameValueUpdate::into_wr));
            properties.floats.extend(floats.into_iter().filter_map(FrameValueUpdate::into_wr));
            properties.colors.extend(colors.into_iter().filter_map(FrameValueUpdate::into_wr));

            if properties.transforms.is_empty() && properties.floats.is_empty() && properties.colors.is_empty() {
                Ok(None)
            } else {
                Ok(Some(properties))
            }
        }
    }
}

/// Represents one of the filters applied to a stacking context.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum FilterOp {
    /// Blur, width and height in pixels.
    Blur(f32, f32),
    /// Brightness, in [0..=1] range.
    Brightness(f32),
    /// Contrast, in [0..=1] range.
    Contrast(f32),
    /// Grayscale, in [0..=1] range.
    Grayscale(f32),
    /// Hue shift, in degrees.
    HueRotate(f32),
    /// Invert, in [0..=1] range.
    Invert(f32),
    /// Opacity, in [0..=1] range, can be bound.
    Opacity(FrameValue<f32>),
    /// Saturation, in [0..=1] range.
    Saturate(f32),
    /// Sepia, in [0..=1] range.
    Sepia(f32),
    /// Pixel perfect shadow.
    DropShadow {
        /// Shadow offset.
        offset: euclid::Vector2D<f32, Px>,
        /// Shadow color.
        color: Rgba,
        /// Shadow blur.
        blur_radius: f32,
    },
    /// Custom filter.
    ///
    /// The color matrix is in the format of SVG color matrix, [0..5] is the first matrix row.
    ColorMatrix([f32; 20]),
    /// Fill with color.
    Flood(Rgba),
}
impl FilterOp {
    /// To webrender filter-op.
    pub fn to_wr(self) -> wr::FilterOp {
        match self {
            FilterOp::Blur(w, h) => wr::FilterOp::Blur(w, h),
            FilterOp::Brightness(b) => wr::FilterOp::Brightness(b),
            FilterOp::Contrast(c) => wr::FilterOp::Contrast(c),
            FilterOp::Grayscale(g) => wr::FilterOp::Grayscale(g),
            FilterOp::HueRotate(h) => wr::FilterOp::HueRotate(h),
            FilterOp::Invert(i) => wr::FilterOp::Invert(i),
            FilterOp::Opacity(o) => wr::FilterOp::Opacity(o.into_wr(), *o.value()),
            FilterOp::Saturate(s) => wr::FilterOp::Saturate(s),
            FilterOp::Sepia(s) => wr::FilterOp::Sepia(s),
            FilterOp::DropShadow {
                offset,
                color,
                blur_radius,
            } => wr::FilterOp::DropShadow(wr::Shadow {
                offset: offset.cast_unit(),
                color: color.to_wr(),
                blur_radius,
            }),
            FilterOp::ColorMatrix(m) => wr::FilterOp::ColorMatrix([
                m[0], m[5], m[10], m[15], m[1], m[6], m[11], m[16], m[2], m[7], m[12], m[17], m[3], m[8], m[13], m[18], m[4], m[9], m[14],
                m[19],
            ]),
            FilterOp::Flood(c) => wr::FilterOp::Flood(c.to_wr()),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum DisplayItem {
    Reuse {
        frame_id: FrameId,
        seg_id: SegmentId,
        start: usize,
        end: usize,
    },
    PushReferenceFrame {
        key: wr::SpatialTreeItemKey,
        transform: FrameValue<PxTransform>,
        transform_style: wr::TransformStyle,
        is_2d_scale_translation: bool,
    },
    PopReferenceFrame,

    PushStackingContext {
        transform_style: wr::TransformStyle,
        blend_mode: wr::MixBlendMode,
        filters: Box<[FilterOp]>,
        filter_datas: Box<[wr::FilterData]>,
        filter_primitives: Box<[wr::FilterPrimitive]>,
    },
    PopStackingContext,

    PushClipRect {
        clip_rect: PxRect,
        clip_out: bool,
    },
    PushClipRoundedRect {
        clip_rect: PxRect,
        corners: PxCornerRadius,
        clip_out: bool,
    },
    PopClip,
    PushMask {
        image_id: ImageTextureId,
        rect: PxRect,
    },
    PopMask,

    Border {
        bounds: PxRect,
        widths: PxSideOffsets,
        sides: [BorderSide; 4],
        radius: PxCornerRadius,
    },
    NinePatchBorder {
        bounds: PxRect,
        source: NinePatchSource,
        widths: PxSideOffsets,
        fill: bool,
        repeat_horizontal: wr::RepeatMode,
        repeat_vertical: wr::RepeatMode,
    },

    Text {
        clip_rect: PxRect,
        font_id: FontId,
        glyphs: Box<[GlyphInstance]>,
        color: FrameValue<Rgba>,
        options: GlyphOptions,
    },

    Image {
        clip_rect: PxRect,
        image_id: ImageTextureId,
        image_size: PxSize,
        rendering: wr::ImageRendering,
        alpha_type: wr::AlphaType,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },

    Color {
        clip_rect: PxRect,
        color: FrameValue<Rgba>,
    },
    BackdropFilter {
        clip_rect: PxRect,
        filters: Box<[FilterOp]>,
        filter_datas: Box<[wr::FilterData]>,
        filter_primitives: Box<[wr::FilterPrimitive]>,
    },

    LinearGradient {
        clip_rect: PxRect,
        gradient: wr::Gradient,
        stops: Box<[GradientStop]>,
        tile_origin: PxPoint,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },
    RadialGradient {
        clip_rect: PxRect,
        gradient: wr::RadialGradient,
        stops: Box<[GradientStop]>,
        tile_origin: PxPoint,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },
    ConicGradient {
        clip_rect: PxRect,
        gradient: wr::ConicGradient,
        stops: Box<[GradientStop]>,
        tile_origin: PxPoint,
        tile_size: PxSize,
        tile_spacing: PxSize,
    },

    Line {
        clip_rect: PxRect,
        color: Rgba,
        style: wr::LineStyle,
        wavy_line_thickness: f32,
        orientation: wr::LineOrientation,
    },

    PushExtension {
        extension_id: ApiExtensionId,
        payload: ApiExtensionPayload,
    },
    PopExtension {
        extension_id: ApiExtensionId,
    },

    SetBackfaceVisibility {
        visible: bool,
    },
}
impl DisplayItem {
    fn to_webrender(
        &self,
        wr_list: &mut wr::DisplayListBuilder,
        ext: &mut dyn DisplayListExtension,
        sc: &mut SpaceAndClip,
        cache: &DisplayListCache,
        is_reuse: bool,
    ) {
        match self {
            DisplayItem::Reuse {
                frame_id,
                seg_id,
                start,
                end,
            } => cache.reuse(*frame_id, *seg_id, *start, *end, wr_list, ext, sc),

            DisplayItem::PushReferenceFrame {
                key,
                transform,
                transform_style,
                is_2d_scale_translation,
            } => {
                let spatial_id = wr_list.push_reference_frame(
                    wr::units::LayoutPoint::zero(),
                    sc.spatial_id(),
                    *transform_style,
                    transform.into_wr(),
                    wr::ReferenceFrameKind::Transform {
                        is_2d_scale_translation: *is_2d_scale_translation,
                        should_snap: false,
                        paired_with_perspective: false,
                    },
                    *key,
                );
                sc.push_spatial(spatial_id);
            }
            DisplayItem::PopReferenceFrame => {
                wr_list.pop_reference_frame();
                sc.pop_spatial();
            }

            DisplayItem::PushStackingContext {
                blend_mode,
                transform_style,
                filters,
                filter_datas,
                filter_primitives,
            } => {
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_stacking_context(
                    wr::units::LayoutPoint::zero(),
                    sc.spatial_id(),
                    sc.primitive_flags(),
                    Some(clip),
                    *transform_style,
                    *blend_mode,
                    &filters.iter().map(|f| f.to_wr()).collect::<Vec<_>>(),
                    filter_datas,
                    filter_primitives,
                    wr::RasterSpace::Screen, // Local disables sub-pixel AA for performance (future perf.)
                    wr::StackingContextFlags::empty(),
                )
            }
            DisplayItem::PopStackingContext => wr_list.pop_stacking_context(),

            DisplayItem::PushClipRect { clip_rect, clip_out } => {
                let clip_id = if *clip_out {
                    wr_list.define_clip_rounded_rect(
                        sc.spatial_id(),
                        wr::ComplexClipRegion::new(clip_rect.to_wr(), PxCornerRadius::zero().to_wr(), wr::ClipMode::ClipOut),
                    )
                } else {
                    wr_list.define_clip_rect(sc.spatial_id(), clip_rect.to_wr())
                };

                sc.push_clip(clip_id);
            }
            DisplayItem::PushClipRoundedRect {
                clip_rect,
                corners,
                clip_out,
            } => {
                let clip_id = wr_list.define_clip_rounded_rect(
                    sc.spatial_id(),
                    wr::ComplexClipRegion::new(
                        clip_rect.to_wr(),
                        corners.to_wr(),
                        if *clip_out { wr::ClipMode::ClipOut } else { wr::ClipMode::Clip },
                    ),
                );
                sc.push_clip(clip_id);
            }
            DisplayItem::PopClip => sc.pop_clip(),

            DisplayItem::PushMask { image_id, rect } => {
                let clip_id = wr_list.define_clip_image_mask(
                    sc.spatial_id(),
                    wr::ImageMask {
                        image: wr::ImageKey(cache.id_namespace(), image_id.get()),
                        rect: rect.to_wr(),
                    },
                    &[],
                    wr::FillRule::Nonzero,
                );
                sc.push_clip(clip_id);
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_stacking_context(
                    wr::units::LayoutPoint::zero(),
                    sc.spatial_id(),
                    sc.primitive_flags(),
                    Some(clip),
                    wr::TransformStyle::Flat,
                    wr::MixBlendMode::Normal,
                    &[],
                    &[],
                    &[],
                    wr::RasterSpace::Screen,
                    wr::StackingContextFlags::empty(),
                );
            }
            DisplayItem::PopMask => {
                wr_list.pop_stacking_context();
                sc.pop_clip();
            }

            DisplayItem::SetBackfaceVisibility { visible } => {
                sc.set_backface_visibility(*visible);
            }

            DisplayItem::Text {
                clip_rect,
                font_id,
                glyphs,
                color,
                options,
            } => {
                let bounds = clip_rect.to_wr();
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_text(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    bounds,
                    cast_glyphs_to_wr(glyphs),
                    wr::FontInstanceKey(cache.id_namespace(), font_id.get()),
                    color.into_value().to_wr(),
                    options.clone().to_wr_world(),
                );
            }

            DisplayItem::Color { clip_rect, color } => {
                let bounds = clip_rect.to_wr();
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_rect_with_animation(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    bounds,
                    color.into_wr(),
                )
            }
            DisplayItem::BackdropFilter {
                clip_rect,
                filters,
                filter_datas,
                filter_primitives,
            } => {
                let bounds = clip_rect.to_wr();
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_backdrop_filter(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    &filters.iter().map(|f| f.to_wr()).collect::<Vec<_>>(),
                    filter_datas,
                    filter_primitives,
                )
            }

            DisplayItem::Border {
                bounds,
                widths,
                sides: [top, right, bottom, left],
                radius,
            } => {
                let bounds = bounds.to_wr();
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_border(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    bounds,
                    widths.to_wr(),
                    wr::BorderDetails::Normal(wr::NormalBorder {
                        left: left.to_wr(),
                        right: right.to_wr(),
                        top: top.to_wr(),
                        bottom: bottom.to_wr(),
                        radius: radius.to_wr(),
                        do_aa: true,
                    }),
                );
            }
            DisplayItem::NinePatchBorder {
                source,
                bounds,
                widths,
                fill,
                repeat_horizontal,
                repeat_vertical,
            } => {
                let wr_bounds = bounds.to_wr();
                let clip = sc.clip_chain_id(wr_list);

                let source = match source {
                    NinePatchSource::Image { image_id, rendering } => {
                        wr::NinePatchBorderSource::Image(wr::ImageKey(cache.id_namespace(), image_id.get()), *rendering)
                    }
                    NinePatchSource::LinearGradient { gradient, stops } => {
                        let stops: Vec<_> = stops
                            .iter()
                            .map(|s| wr::GradientStop {
                                offset: s.offset,
                                color: s.color.to_wr(),
                            })
                            .collect();
                        wr_list.push_stops(&stops);
                        wr::NinePatchBorderSource::Gradient(*gradient)
                    }
                    NinePatchSource::RadialGradient { gradient, stops } => {
                        let stops: Vec<_> = stops
                            .iter()
                            .map(|s| wr::GradientStop {
                                offset: s.offset,
                                color: s.color.to_wr(),
                            })
                            .collect();
                        wr_list.push_stops(&stops);
                        wr::NinePatchBorderSource::RadialGradient(*gradient)
                    }
                    NinePatchSource::ConicGradient { gradient, stops } => {
                        let stops: Vec<_> = stops
                            .iter()
                            .map(|s| wr::GradientStop {
                                offset: s.offset,
                                color: s.color.to_wr(),
                            })
                            .collect();
                        wr_list.push_stops(&stops);
                        wr::NinePatchBorderSource::ConicGradient(*gradient)
                    }
                };

                wr_list.push_border(
                    &wr::CommonItemProperties {
                        clip_rect: wr_bounds,
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    wr_bounds,
                    widths.to_wr(),
                    wr::BorderDetails::NinePatch(wr::NinePatchBorder {
                        source,
                        width: bounds.width().0,
                        height: bounds.height().0,
                        slice: widths.to_wr_device(),
                        fill: *fill,
                        repeat_horizontal: *repeat_horizontal,
                        repeat_vertical: *repeat_vertical,
                    }),
                );
            }

            DisplayItem::Image {
                clip_rect,
                image_id,
                image_size,
                rendering,
                alpha_type,
                tile_size,
                tile_spacing,
            } => {
                let bounds = clip_rect.to_wr();
                let clip = sc.clip_chain_id(wr_list);
                let props = wr::CommonItemProperties {
                    clip_rect: bounds,
                    clip_chain_id: clip,
                    spatial_id: sc.spatial_id(),
                    flags: sc.primitive_flags(),
                };

                if tile_spacing.is_empty() && tile_size == image_size {
                    wr_list.push_image(
                        &props,
                        PxRect::from_size(*image_size).to_wr(),
                        *rendering,
                        *alpha_type,
                        wr::ImageKey(cache.id_namespace(), image_id.get()),
                        wr::ColorF::WHITE,
                    );
                } else {
                    wr_list.push_repeating_image(
                        &props,
                        PxRect::from_size(*image_size).to_wr(),
                        tile_size.to_wr(),
                        tile_spacing.to_wr(),
                        *rendering,
                        *alpha_type,
                        wr::ImageKey(cache.id_namespace(), image_id.get()),
                        wr::ColorF::WHITE,
                    );
                }
            }

            DisplayItem::LinearGradient {
                clip_rect,
                gradient,
                stops,
                mut tile_origin,
                tile_size,
                tile_spacing,
            } => {
                tile_origin.x.0 = tile_origin.x.0.rem_euclid(tile_size.width.0);
                tile_origin.y.0 = tile_origin.y.0.rem_euclid(tile_size.height.0);
                let bounds = PxRect::new(
                    -tile_origin + clip_rect.origin.to_vector(),
                    clip_rect.size + tile_origin.to_vector().to_size(),
                )
                .to_wr();

                let clip = sc.clip_chain_id(wr_list);
                // stops needs to be immediately followed by the gradient, if the clip-chain item
                // is inserted in the between the stops are lost.
                let stops: Vec<_> = stops
                    .iter()
                    .map(|s| wr::GradientStop {
                        offset: s.offset,
                        color: s.color.to_wr(),
                    })
                    .collect();
                wr_list.push_stops(&stops);
                wr_list.push_gradient(
                    &wr::CommonItemProperties {
                        clip_rect: clip_rect.to_wr(),
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    bounds,
                    *gradient,
                    tile_size.to_wr(),
                    tile_spacing.to_wr(),
                )
            }
            DisplayItem::RadialGradient {
                clip_rect,
                gradient,
                stops,
                mut tile_origin,
                tile_size,
                tile_spacing,
            } => {
                tile_origin.x.0 = tile_origin.x.0.rem_euclid(tile_size.width.0);
                tile_origin.y.0 = tile_origin.y.0.rem_euclid(tile_size.height.0);
                let bounds = PxRect::new(
                    -tile_origin + clip_rect.origin.to_vector(),
                    clip_rect.size + tile_origin.to_vector().to_size(),
                )
                .to_wr();

                let clip = sc.clip_chain_id(wr_list);
                let stops: Vec<_> = stops
                    .iter()
                    .map(|s| wr::GradientStop {
                        offset: s.offset,
                        color: s.color.to_wr(),
                    })
                    .collect();
                wr_list.push_stops(&stops);
                wr_list.push_radial_gradient(
                    &wr::CommonItemProperties {
                        clip_rect: clip_rect.to_wr(),
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    bounds,
                    *gradient,
                    tile_size.to_wr(),
                    tile_spacing.to_wr(),
                )
            }
            DisplayItem::ConicGradient {
                clip_rect,
                gradient,
                stops,
                mut tile_origin,
                tile_size,
                tile_spacing,
            } => {
                tile_origin.x.0 = tile_origin.x.0.rem_euclid(tile_size.width.0);
                tile_origin.y.0 = tile_origin.y.0.rem_euclid(tile_size.height.0);
                let bounds = PxRect::new(
                    -tile_origin + clip_rect.origin.to_vector(),
                    clip_rect.size + tile_origin.to_vector().to_size(),
                )
                .to_wr();

                let clip = sc.clip_chain_id(wr_list);
                let stops: Vec<_> = stops
                    .iter()
                    .map(|s| wr::GradientStop {
                        offset: s.offset,
                        color: s.color.to_wr(),
                    })
                    .collect();
                wr_list.push_stops(&stops);
                wr_list.push_conic_gradient(
                    &wr::CommonItemProperties {
                        clip_rect: clip_rect.to_wr(),
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    bounds,
                    *gradient,
                    tile_size.to_wr(),
                    tile_spacing.to_wr(),
                )
            }
            DisplayItem::Line {
                clip_rect,
                color,
                style,
                wavy_line_thickness,
                orientation,
            } => {
                let bounds = clip_rect.to_wr();
                let clip = sc.clip_chain_id(wr_list);
                wr_list.push_line(
                    &wr::CommonItemProperties {
                        clip_rect: bounds,
                        clip_chain_id: clip,
                        spatial_id: sc.spatial_id(),
                        flags: sc.primitive_flags(),
                    },
                    &bounds,
                    *wavy_line_thickness,
                    *orientation,
                    &color.to_wr(),
                    *style,
                );
            }
            DisplayItem::PushExtension { extension_id, payload } => ext.push_display_item(&mut DisplayExtensionItemArgs {
                extension_id: *extension_id,
                payload,
                is_reuse,
                list: wr_list,
                sc,
            }),
            DisplayItem::PopExtension { extension_id } => ext.pop_display_item(&mut DisplayExtensionItemArgs {
                extension_id: *extension_id,
                payload: &ApiExtensionPayload::empty(),
                is_reuse,
                list: wr_list,
                sc,
            }),
        }
    }

    fn register_bindings(&self, bindings: &mut FxHashMap<wr::PropertyBindingId, (FrameId, usize)>, value: (FrameId, usize)) {
        match self {
            DisplayItem::PushReferenceFrame {
                transform: FrameValue::Bind { key, .. },
                ..
            } => {
                bindings.insert(key.id, value);
            }
            DisplayItem::PushStackingContext { filters, .. } => {
                for filter in filters.iter() {
                    if let FilterOp::Opacity(FrameValue::Bind { key, .. }) = filter {
                        bindings.insert(key.id, value);
                    }
                }
            }
            DisplayItem::Color {
                color: FrameValue::Bind { key, .. },
                ..
            } => {
                bindings.insert(key.id, value);
            }
            DisplayItem::Text {
                color: FrameValue::Bind { key, .. },
                ..
            } => {
                bindings.insert(key.id, value);
            }
            _ => {}
        }
    }

    /// Update the value and returns if a new full frame must be rendered.
    fn update_transform(&mut self, t: &FrameValueUpdate<PxTransform>) -> bool {
        match self {
            DisplayItem::PushReferenceFrame {
                transform:
                    FrameValue::Bind {
                        key,
                        value,
                        animating: animation,
                    },
                ..
            } if *key == t.key => FrameValue::update_bindable(value, animation, t),
            _ => false,
        }
    }
    fn update_float(&mut self, t: &FrameValueUpdate<f32>) -> bool {
        match self {
            DisplayItem::PushStackingContext { filters, .. } => {
                let mut new_frame = false;
                for filter in filters.iter_mut() {
                    match filter {
                        FilterOp::Opacity(FrameValue::Bind {
                            key,
                            value,
                            animating: animation,
                        }) if *key == t.key => {
                            new_frame |= FrameValue::update_bindable(value, animation, t);
                        }
                        _ => {}
                    }
                }
                new_frame
            }
            _ => false,
        }
    }
    fn update_color(&mut self, t: &FrameValueUpdate<Rgba>) -> bool {
        match self {
            DisplayItem::Color {
                color:
                    FrameValue::Bind {
                        key,
                        value,
                        animating: animation,
                    },
                ..
            } if *key == t.key => FrameValue::update_bindable(value, animation, t),
            DisplayItem::Text {
                color: FrameValue::Bind { key, value, .. },
                ..
            } if *key == t.key => FrameValue::update_value(value, t),
            _ => false,
        }
    }

    // fn name(&self) -> &'static str {
    //     serde_variant::to_variant_name(self).unwrap_or("")
    // }
}

/// Nine-patch image source.
#[allow(missing_docs)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NinePatchSource {
    Image {
        image_id: ImageTextureId,
        rendering: wr::ImageRendering,
    },
    LinearGradient {
        gradient: wr::Gradient,
        stops: Box<[GradientStop]>,
    },
    RadialGradient {
        gradient: wr::RadialGradient,
        stops: Box<[GradientStop]>,
    },
    ConicGradient {
        gradient: wr::ConicGradient,
        stops: Box<[GradientStop]>,
    },
}

/// Tracks the current space & clip chain, and the backface visibility primitive flag.
pub struct SpaceAndClip {
    spatial_stack: Vec<wr::SpatialId>,
    clip_stack: Vec<wr::ClipId>,
    clip_chain_stack: Vec<(wr::ClipChainId, usize)>,
    prim_flags: wr::PrimitiveFlags,
}
impl SpaceAndClip {
    pub(crate) fn new(pipeline_id: PipelineId) -> Self {
        let sid = wr::SpatialId::root_reference_frame(pipeline_id);
        SpaceAndClip {
            spatial_stack: vec![sid],
            clip_stack: vec![],
            clip_chain_stack: vec![],
            prim_flags: wr::PrimitiveFlags::IS_BACKFACE_VISIBLE,
        }
    }

    /// Current space.
    pub fn spatial_id(&self) -> wr::SpatialId {
        self.spatial_stack[self.spatial_stack.len() - 1]
    }

    /// Current clip chain.
    pub fn clip_chain_id(&mut self, list: &mut wr::DisplayListBuilder) -> wr::ClipChainId {
        let mut start = 0;
        let mut parent = None;

        if let Some((id, i)) = self.clip_chain_stack.last().copied() {
            if i == self.clip_stack.len() {
                return id;
            } else {
                start = i;
                parent = Some(id);
            }
        }

        let clips = self.clip_stack[start..].iter().copied();
        let id = list.define_clip_chain(parent, clips);
        self.clip_chain_stack.push((id, self.clip_stack.len()));

        id
    }

    /// Push space.
    pub fn push_spatial(&mut self, spatial_id: wr::SpatialId) {
        self.spatial_stack.push(spatial_id);
    }

    /// Pop space.
    pub fn pop_spatial(&mut self) {
        self.spatial_stack.truncate(self.spatial_stack.len() - 1);
    }

    /// Push clip.
    pub fn push_clip(&mut self, clip: wr::ClipId) {
        self.clip_stack.push(clip);
    }

    /// Pop clip.
    pub fn pop_clip(&mut self) {
        self.clip_stack.truncate(self.clip_stack.len() - 1);

        if let Some((_, i)) = self.clip_chain_stack.last() {
            if *i > self.clip_stack.len() {
                self.clip_chain_stack.truncate(self.clip_chain_stack.len() - 1);
            }
        }
    }

    /// Gets the primitive flags for the item.
    pub fn primitive_flags(&self) -> wr::PrimitiveFlags {
        self.prim_flags
    }

    /// Set the `IS_BACKFACE_VISIBLE` flag to the next items.
    pub fn set_backface_visibility(&mut self, visible: bool) {
        self.prim_flags.set(wr::PrimitiveFlags::IS_BACKFACE_VISIBLE, visible);
    }

    pub(crate) fn clear(&mut self, pipeline_id: PipelineId) {
        #[cfg(debug_assertions)]
        {
            if self.clip_chain_stack.len() >= 2 {
                tracing::error!("found {} clip chains, expected 0 or 1", self.clip_chain_stack.len());
            }
            if !self.clip_stack.is_empty() {
                tracing::error!("found {} clips, expected 0", self.clip_stack.len());
            }
            if self.spatial_stack.len() != 1 {
                tracing::error!("found {} spatial, expected 1 root_reference_frame", self.spatial_stack.len());
            } else if self.spatial_stack[0].0 != 0 {
                tracing::error!("found other spatial id, expected root_reference_frame");
            }
        }

        self.clip_stack.clear();

        self.spatial_stack.clear();
        self.spatial_stack.push(wr::SpatialId::root_reference_frame(pipeline_id));

        self.clip_chain_stack.clear();

        self.prim_flags = wr::PrimitiveFlags::IS_BACKFACE_VISIBLE;
    }
}

/// Arguments for [`DisplayListExtension`] begin/end list.
pub struct DisplayExtensionArgs<'a> {
    /// The webrender display list.
    pub list: &'a mut wr::DisplayListBuilder,
    /// Space and clip tracker.
    pub sc: &'a mut SpaceAndClip,
}

/// Arguments for [`DisplayListExtension`] push and pop.
pub struct DisplayExtensionItemArgs<'a> {
    /// Extension index.
    pub extension_id: ApiExtensionId,
    /// Push payload, is empty for pop.
    pub payload: &'a ApiExtensionPayload,
    /// If the display item is reused.
    ///
    /// If `true` the payload is the same as received before any updates, the updated
    /// values must be applied to value deserialized from the payload.
    pub is_reuse: bool,
    /// The webrender display list.
    pub list: &'a mut wr::DisplayListBuilder,
    /// Space and clip tracker.
    pub sc: &'a mut SpaceAndClip,
}

/// Arguments for [`DisplayListExtension`] update.
pub struct DisplayExtensionUpdateArgs<'a> {
    /// Extension index.
    pub extension_id: ApiExtensionId,
    /// Update payload.
    pub payload: &'a ApiExtensionPayload,

    /// Set to `true` to rebuild the display list.
    ///
    /// The list will be rebuild using the last full payload received, the extension
    /// must patch in any subsequent updates onto this value.
    pub new_frame: bool,

    /// Webrender binding updates.
    ///
    /// If no other extension and update handlers request a new frame these properties
    /// will be send to Webrender to update the current frame.
    pub properties: &'a mut wr::DynamicProperties,
}

/// Handler for display list extension items.
///
/// Note that this is for extensions that still use Webrender, to generate normal
/// Webrender items or *blobs* that are Webrender's own extension mechanism.
/// Custom renderers can just inspect the display list directly.
///
/// This trait is implemented for `()` for view implementations that don't provide any extension.
pub trait DisplayListExtension {
    /// Handle new display list starting.
    ///
    /// This is called for every list, even if the list does not have any item for the extension.
    fn display_list_start(&mut self, args: &mut DisplayExtensionArgs) {
        let _ = args;
    }

    /// Handle extension push.
    ///
    /// This is only called for items addressing the extension.
    fn push_display_item(&mut self, args: &mut DisplayExtensionItemArgs);
    /// Handle extension pop.
    ///
    /// This is only called for items addressing the extension.
    fn pop_display_item(&mut self, args: &mut DisplayExtensionItemArgs) {
        let _ = args;
    }

    /// Handle display list finishing.
    fn display_list_end(&mut self, args: &mut DisplayExtensionArgs) {
        let _ = args;
    }

    /// Handle extension update.
    fn update(&mut self, args: &mut DisplayExtensionUpdateArgs) {
        let _ = args;
    }
}
impl DisplayListExtension for () {
    fn push_display_item(&mut self, args: &mut DisplayExtensionItemArgs) {
        let _ = args;
    }
}
